<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotSession.java</span></div><h1>CopilotSession.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.AssistantMessageEvent;
import com.github.copilot.sdk.events.SessionErrorEvent;
import com.github.copilot.sdk.events.SessionEventParser;
import com.github.copilot.sdk.events.SessionIdleEvent;
import com.github.copilot.sdk.json.GetMessagesResponse;
import com.github.copilot.sdk.json.HookInvocation;
import com.github.copilot.sdk.json.MessageOptions;
import com.github.copilot.sdk.json.PermissionHandler;
import com.github.copilot.sdk.json.PermissionInvocation;
import com.github.copilot.sdk.json.PermissionRequest;
import com.github.copilot.sdk.json.PermissionRequestResult;
import com.github.copilot.sdk.json.PostToolUseHookInput;
import com.github.copilot.sdk.json.PreToolUseHookInput;
import com.github.copilot.sdk.json.SendMessageRequest;
import com.github.copilot.sdk.json.SendMessageResponse;
import com.github.copilot.sdk.json.SessionEndHookInput;
import com.github.copilot.sdk.json.SessionHooks;
import com.github.copilot.sdk.json.SessionStartHookInput;
import com.github.copilot.sdk.json.ToolDefinition;
import com.github.copilot.sdk.json.UserInputHandler;
import com.github.copilot.sdk.json.UserInputInvocation;
import com.github.copilot.sdk.json.UserInputRequest;
import com.github.copilot.sdk.json.UserInputResponse;
import com.github.copilot.sdk.json.UserPromptSubmittedHookInput;

/**
 * Represents a single conversation session with the Copilot CLI.
 * &lt;p&gt;
 * A session maintains conversation state, handles events, and manages tool
 * execution. Sessions are created via {@link CopilotClient#createSession} or
 * resumed via {@link CopilotClient#resumeSession}.
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Create a session
 * var session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * // Register type-safe event handlers
 * session.on(AssistantMessageEvent.class, msg -&gt; {
 * 	System.out.println(msg.getData().content());
 * });
 * session.on(SessionIdleEvent.class, idle -&gt; {
 * 	System.out.println(&quot;Session is idle&quot;);
 * });
 *
 * // Send messages
 * session.sendAndWait(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 *
 * // Clean up
 * session.close();
 * }&lt;/pre&gt;
 *
 * @see CopilotClient#createSession(com.github.copilot.sdk.json.SessionConfig)
 * @see CopilotClient#resumeSession(String,
 *      com.github.copilot.sdk.json.ResumeSessionConfig)
 * @see AbstractSessionEvent
 * @since 1.0.0
 */
public final class CopilotSession implements AutoCloseable {

<span class="fc" id="L87">    private static final Logger LOG = Logger.getLogger(CopilotSession.class.getName());</span>
<span class="fc" id="L88">    private static final ObjectMapper MAPPER = JsonRpcClient.getObjectMapper();</span>

    private final String sessionId;
    private final String workspacePath;
    private final JsonRpcClient rpc;
<span class="fc" id="L93">    private final Set&lt;Consumer&lt;AbstractSessionEvent&gt;&gt; eventHandlers = ConcurrentHashMap.newKeySet();</span>
<span class="fc" id="L94">    private final Map&lt;String, ToolDefinition&gt; toolHandlers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L95">    private final AtomicReference&lt;PermissionHandler&gt; permissionHandler = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L96">    private final AtomicReference&lt;UserInputHandler&gt; userInputHandler = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L97">    private final AtomicReference&lt;SessionHooks&gt; hooksHandler = new AtomicReference&lt;&gt;();</span>
    private volatile EventErrorHandler eventErrorHandler;
<span class="fc" id="L99">    private volatile EventErrorPolicy eventErrorPolicy = EventErrorPolicy.PROPAGATE_AND_LOG_ERRORS;</span>

    /** Tracks whether this session instance has been terminated via close(). */
<span class="fc" id="L102">    private volatile boolean isTerminated = false;</span>

    /**
     * Creates a new session with the given ID and RPC client.
     * &lt;p&gt;
     * This constructor is package-private. Sessions should be created via
     * {@link CopilotClient#createSession} or {@link CopilotClient#resumeSession}.
     *
     * @param sessionId
     *            the unique session identifier
     * @param rpc
     *            the JSON-RPC client for communication
     */
    CopilotSession(String sessionId, JsonRpcClient rpc) {
<span class="fc" id="L116">        this(sessionId, rpc, null);</span>
<span class="fc" id="L117">    }</span>

    /**
     * Creates a new session with the given ID, RPC client, and workspace path.
     * &lt;p&gt;
     * This constructor is package-private. Sessions should be created via
     * {@link CopilotClient#createSession} or {@link CopilotClient#resumeSession}.
     *
     * @param sessionId
     *            the unique session identifier
     * @param rpc
     *            the JSON-RPC client for communication
     * @param workspacePath
     *            the workspace path if infinite sessions are enabled
     */
<span class="fc" id="L132">    CopilotSession(String sessionId, JsonRpcClient rpc, String workspacePath) {</span>
<span class="fc" id="L133">        this.sessionId = sessionId;</span>
<span class="fc" id="L134">        this.rpc = rpc;</span>
<span class="fc" id="L135">        this.workspacePath = workspacePath;</span>
<span class="fc" id="L136">    }</span>

    /**
     * Gets the unique identifier for this session.
     *
     * @return the session ID
     */
    public String getSessionId() {
<span class="fc" id="L144">        return sessionId;</span>
    }

    /**
     * Gets the path to the session workspace directory when infinite sessions are
     * enabled.
     * &lt;p&gt;
     * The workspace directory contains checkpoints/, plan.md, and files/
     * subdirectories.
     *
     * @return the workspace path, or {@code null} if infinite sessions are disabled
     */
    public String getWorkspacePath() {
<span class="fc" id="L157">        return workspacePath;</span>
    }

    /**
     * Sets a custom error handler for exceptions thrown by event handlers.
     * &lt;p&gt;
     * When an event handler registered via {@link #on(Consumer)} or
     * {@link #on(Class, Consumer)} throws an exception during event dispatch, the
     * error handler is invoked with the event and exception. The error is always
     * logged at {@link Level#WARNING} regardless of whether a custom handler is
     * set.
     *
     * &lt;p&gt;
     * Whether dispatch continues or stops after an error is controlled by the
     * {@link EventErrorPolicy} set via {@link #setEventErrorPolicy}. The error
     * handler is always invoked regardless of the policy.
     *
     * &lt;p&gt;
     * If the error handler itself throws an exception, that exception is caught and
     * logged at {@link Level#SEVERE}, and dispatch is stopped regardless of the
     * configured policy.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * session.setEventErrorHandler((event, exception) -&gt; {
     * 	metrics.increment(&quot;handler.errors&quot;);
     * 	logger.error(&quot;Handler failed on {}: {}&quot;, event.getType(), exception.getMessage());
     * });
     * }&lt;/pre&gt;
     *
     * @param handler
     *            the error handler, or {@code null} to use only the default logging
     *            behavior
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see EventErrorHandler
     * @see #setEventErrorPolicy(EventErrorPolicy)
     * @since 1.0.8
     */
    public void setEventErrorHandler(EventErrorHandler handler) {
<span class="fc" id="L199">        ensureNotTerminated();</span>
<span class="fc" id="L200">        this.eventErrorHandler = handler;</span>
<span class="fc" id="L201">    }</span>

    /**
     * Sets the error propagation policy for event dispatch.
     * &lt;p&gt;
     * Controls whether remaining event listeners continue to execute when a
     * preceding listener throws an exception. Errors are always logged at
     * {@link Level#WARNING} regardless of the policy.
     *
     * &lt;ul&gt;
     * &lt;li&gt;{@link EventErrorPolicy#PROPAGATE_AND_LOG_ERRORS} (default) — log the
     * error and stop dispatch after the first error&lt;/li&gt;
     * &lt;li&gt;{@link EventErrorPolicy#SUPPRESS_AND_LOG_ERRORS} — log the error and
     * continue dispatching to all remaining listeners&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * The configured {@link EventErrorHandler} (if any) is always invoked
     * regardless of the policy.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * // Opt-in to suppress errors (continue dispatching despite errors)
     * session.setEventErrorPolicy(EventErrorPolicy.SUPPRESS_AND_LOG_ERRORS);
     * session.setEventErrorHandler((event, ex) -&gt; logger.error(&quot;Handler failed, continuing: {}&quot;, ex.getMessage(), ex));
     * }&lt;/pre&gt;
     *
     * @param policy
     *            the error policy (default is
     *            {@link EventErrorPolicy#PROPAGATE_AND_LOG_ERRORS})
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see EventErrorPolicy
     * @see #setEventErrorHandler(EventErrorHandler)
     * @since 1.0.8
     */
    public void setEventErrorPolicy(EventErrorPolicy policy) {
<span class="fc" id="L240">        ensureNotTerminated();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (policy == null) {</span>
<span class="fc" id="L242">            throw new NullPointerException(&quot;policy must not be null&quot;);</span>
        }
<span class="fc" id="L244">        this.eventErrorPolicy = policy;</span>
<span class="fc" id="L245">    }</span>

    /**
     * Sends a simple text message to the Copilot session.
     * &lt;p&gt;
     * This is a convenience method equivalent to
     * {@code send(new MessageOptions().setPrompt(prompt))}.
     *
     * @param prompt
     *            the message text to send
     * @return a future that resolves with the message ID assigned by the server
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see #send(MessageOptions)
     */
    public CompletableFuture&lt;String&gt; send(String prompt) {
<span class="fc" id="L261">        ensureNotTerminated();</span>
<span class="fc" id="L262">        return send(new MessageOptions().setPrompt(prompt));</span>
    }

    /**
     * Sends a simple text message and waits until the session becomes idle.
     * &lt;p&gt;
     * This is a convenience method equivalent to
     * {@code sendAndWait(new MessageOptions().setPrompt(prompt))}.
     *
     * @param prompt
     *            the message text to send
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see #sendAndWait(MessageOptions)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(String prompt) {
<span class="fc" id="L280">        ensureNotTerminated();</span>
<span class="fc" id="L281">        return sendAndWait(new MessageOptions().setPrompt(prompt));</span>
    }

    /**
     * Sends a message to the Copilot session.
     * &lt;p&gt;
     * This method sends a message asynchronously and returns immediately. Use
     * {@link #sendAndWait(MessageOptions)} to wait for the response.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @return a future that resolves with the message ID assigned by the server
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see #sendAndWait(MessageOptions)
     * @see #send(String)
     */
    public CompletableFuture&lt;String&gt; send(MessageOptions options) {
<span class="fc" id="L299">        ensureNotTerminated();</span>
<span class="fc" id="L300">        var request = new SendMessageRequest();</span>
<span class="fc" id="L301">        request.setSessionId(sessionId);</span>
<span class="fc" id="L302">        request.setPrompt(options.getPrompt());</span>
<span class="fc" id="L303">        request.setAttachments(options.getAttachments());</span>
<span class="fc" id="L304">        request.setMode(options.getMode());</span>

<span class="fc" id="L306">        return rpc.invoke(&quot;session.send&quot;, request, SendMessageResponse.class).thenApply(SendMessageResponse::messageId);</span>
    }

    /**
     * Sends a message and waits until the session becomes idle.
     * &lt;p&gt;
     * This method blocks until the assistant finishes processing the message or
     * until the timeout expires. It's suitable for simple request/response
     * interactions where you don't need to process streaming events.
     * &lt;p&gt;
     * The returned future can be cancelled via
     * {@link java.util.concurrent.Future#cancel(boolean)}. If cancelled externally,
     * the future completes with {@link java.util.concurrent.CancellationException}.
     * If the timeout expires first, the future completes exceptionally with a
     * {@link TimeoutException}.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @param timeoutMs
     *            timeout in milliseconds (0 or negative for no timeout)
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received. The future
     *         completes exceptionally with a TimeoutException if the timeout
     *         expires, or with CancellationException if cancelled externally.
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see #sendAndWait(MessageOptions)
     * @see #send(MessageOptions)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(MessageOptions options, long timeoutMs) {
<span class="fc" id="L336">        ensureNotTerminated();</span>
<span class="fc" id="L337">        var future = new CompletableFuture&lt;AssistantMessageEvent&gt;();</span>
<span class="fc" id="L338">        var lastAssistantMessage = new AtomicReference&lt;AssistantMessageEvent&gt;();</span>

<span class="fc" id="L340">        Consumer&lt;AbstractSessionEvent&gt; handler = evt -&gt; {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">            if (evt instanceof AssistantMessageEvent msg) {</span>
<span class="fc" id="L342">                lastAssistantMessage.set(msg);</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            } else if (evt instanceof SessionIdleEvent) {</span>
<span class="fc" id="L344">                future.complete(lastAssistantMessage.get());</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">            } else if (evt instanceof SessionErrorEvent errorEvent) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                String message = errorEvent.getData() != null ? errorEvent.getData().message() : &quot;session error&quot;;</span>
<span class="nc" id="L347">                future.completeExceptionally(new RuntimeException(&quot;Session error: &quot; + message));</span>
            }
<span class="fc" id="L349">        };</span>

<span class="fc" id="L351">        Closeable subscription = on(handler);</span>

<span class="fc" id="L353">        send(options).exceptionally(ex -&gt; {</span>
            try {
<span class="nc" id="L355">                subscription.close();</span>
<span class="nc" id="L356">            } catch (Exception e) {</span>
<span class="nc" id="L357">                LOG.log(Level.SEVERE, &quot;Error closing subscription&quot;, e);</span>
<span class="nc" id="L358">            }</span>
<span class="nc" id="L359">            future.completeExceptionally(ex);</span>
<span class="nc" id="L360">            return null;</span>
        });

        // Set up timeout with daemon thread so it doesn't prevent JVM exit
<span class="fc" id="L364">        var scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; {</span>
<span class="fc" id="L365">            var t = new Thread(r, &quot;sendAndWait-timeout&quot;);</span>
<span class="fc" id="L366">            t.setDaemon(true);</span>
<span class="fc" id="L367">            return t;</span>
        });
<span class="fc" id="L369">        scheduler.schedule(() -&gt; {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">            if (!future.isDone()) {</span>
<span class="fc" id="L371">                future.completeExceptionally(new TimeoutException(&quot;sendAndWait timed out after &quot; + timeoutMs + &quot;ms&quot;));</span>
            }
<span class="fc" id="L373">            scheduler.shutdown();</span>
<span class="fc" id="L374">        }, timeoutMs, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L376">        var result = new CompletableFuture&lt;AssistantMessageEvent&gt;();</span>

        // When inner future completes, run cleanup and propagate to result
<span class="fc" id="L379">        future.whenComplete((r, ex) -&gt; {</span>
            try {
<span class="fc" id="L381">                subscription.close();</span>
<span class="nc" id="L382">            } catch (IOException e) {</span>
<span class="nc" id="L383">                LOG.log(Level.SEVERE, &quot;Error closing subscription&quot;, e);</span>
<span class="fc" id="L384">            }</span>
<span class="fc" id="L385">            scheduler.shutdown();</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (!result.isDone()) {</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                if (ex != null) {</span>
<span class="fc" id="L388">                    result.completeExceptionally(ex);</span>
                } else {
<span class="fc" id="L390">                    result.complete(r);</span>
                }
            }
<span class="fc" id="L393">        });</span>

        // When result is cancelled externally, cancel inner future to trigger cleanup
<span class="fc" id="L396">        result.whenComplete((v, ex) -&gt; {</span>
<span class="pc bpc" id="L397" title="3 of 4 branches missed.">            if (result.isCancelled() &amp;&amp; !future.isDone()) {</span>
<span class="nc" id="L398">                future.cancel(true);</span>
            }
<span class="fc" id="L400">        });</span>

<span class="fc" id="L402">        return result;</span>
    }

    /**
     * Sends a message and waits until the session becomes idle with default 60
     * second timeout.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see #sendAndWait(MessageOptions, long)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(MessageOptions options) {
<span class="fc" id="L418">        ensureNotTerminated();</span>
<span class="fc" id="L419">        return sendAndWait(options, 60000);</span>
    }

    /**
     * Registers a callback for all session events.
     * &lt;p&gt;
     * The handler will be invoked for every event in this session, including
     * assistant messages, tool calls, and session state changes. For type-safe
     * handling of specific event types, prefer {@link #on(Class, Consumer)}
     * instead.
     *
     * &lt;p&gt;
     * &lt;b&gt;Exception handling:&lt;/b&gt; If a handler throws an exception, the error is
     * routed to the configured {@link EventErrorHandler} (if set). Whether
     * remaining handlers execute depends on the configured
     * {@link EventErrorPolicy}.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * // Collect all events
     * var events = new ArrayList&lt;AbstractSessionEvent&gt;();
     * session.on(events::add);
     * }&lt;/pre&gt;
     *
     * @param handler
     *            a callback to be invoked when a session event occurs
     * @return a Closeable that, when closed, unsubscribes the handler
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see #on(Class, Consumer)
     * @see AbstractSessionEvent
     * @see #setEventErrorPolicy(EventErrorPolicy)
     */
    public Closeable on(Consumer&lt;AbstractSessionEvent&gt; handler) {
<span class="fc" id="L455">        ensureNotTerminated();</span>
<span class="fc" id="L456">        eventHandlers.add(handler);</span>
<span class="fc" id="L457">        return () -&gt; eventHandlers.remove(handler);</span>
    }

    /**
     * Registers an event handler for a specific event type.
     * &lt;p&gt;
     * This provides a type-safe way to handle specific events without needing
     * {@code instanceof} checks. The handler will only be called for events
     * matching the specified type.
     *
     * &lt;p&gt;
     * &lt;b&gt;Exception handling:&lt;/b&gt; If a handler throws an exception, the error is
     * routed to the configured {@link EventErrorHandler} (if set). Whether
     * remaining handlers execute depends on the configured
     * {@link EventErrorPolicy}.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example Usage&lt;/b&gt;
     * &lt;/p&gt;
     *
     * &lt;pre&gt;{@code
     * // Handle assistant messages
     * session.on(AssistantMessageEvent.class, msg -&gt; {
     * 	System.out.println(msg.getData().content());
     * });
     *
     * // Handle session idle
     * session.on(SessionIdleEvent.class, idle -&gt; {
     * 	done.complete(null);
     * });
     *
     * // Handle streaming deltas
     * session.on(AssistantMessageDeltaEvent.class, delta -&gt; {
     * 	System.out.print(delta.getData().deltaContent());
     * });
     * }&lt;/pre&gt;
     *
     * @param &lt;T&gt;
     *            the event type
     * @param eventType
     *            the class of the event to listen for
     * @param handler
     *            a callback invoked when events of this type occur
     * @return a Closeable that unsubscribes the handler when closed
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see #on(Consumer)
     * @see AbstractSessionEvent
     */
    public &lt;T extends AbstractSessionEvent&gt; Closeable on(Class&lt;T&gt; eventType, Consumer&lt;T&gt; handler) {
<span class="fc" id="L507">        ensureNotTerminated();</span>
<span class="fc" id="L508">        Consumer&lt;AbstractSessionEvent&gt; wrapper = event -&gt; {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (eventType.isInstance(event)) {</span>
<span class="fc" id="L510">                handler.accept(eventType.cast(event));</span>
            }
<span class="fc" id="L512">        };</span>
<span class="fc" id="L513">        eventHandlers.add(wrapper);</span>
<span class="fc" id="L514">        return () -&gt; eventHandlers.remove(wrapper);</span>
    }

    /**
     * Dispatches an event to all registered handlers.
     * &lt;p&gt;
     * This is called internally when events are received from the server. Each
     * handler is invoked in its own try/catch block. Errors are always logged at
     * {@link Level#WARNING}. Whether dispatch continues after a handler error
     * depends on the configured {@link EventErrorPolicy}:
     * &lt;ul&gt;
     * &lt;li&gt;{@link EventErrorPolicy#PROPAGATE_AND_LOG_ERRORS} (default) — dispatch
     * stops after the first error&lt;/li&gt;
     * &lt;li&gt;{@link EventErrorPolicy#SUPPRESS_AND_LOG_ERRORS} — remaining handlers
     * still execute&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The configured {@link EventErrorHandler} is always invoked (if set),
     * regardless of the policy. If the error handler itself throws, dispatch stops
     * regardless of policy and the error is logged at {@link Level#SEVERE}.
     *
     * @param event
     *            the event to dispatch
     * @see #setEventErrorHandler(EventErrorHandler)
     * @see #setEventErrorPolicy(EventErrorPolicy)
     */
    void dispatchEvent(AbstractSessionEvent event) {
<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (Consumer&lt;AbstractSessionEvent&gt; handler : eventHandlers) {</span>
            try {
<span class="fc" id="L543">                handler.accept(event);</span>
<span class="fc" id="L544">            } catch (Exception e) {</span>
<span class="fc" id="L545">                LOG.log(Level.WARNING, &quot;Error in event handler&quot;, e);</span>
<span class="fc" id="L546">                EventErrorHandler errorHandler = this.eventErrorHandler;</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                if (errorHandler != null) {</span>
                    try {
<span class="fc" id="L549">                        errorHandler.handleError(event, e);</span>
<span class="fc" id="L550">                    } catch (Exception errorHandlerException) {</span>
<span class="fc" id="L551">                        LOG.log(Level.SEVERE, &quot;Error in event error handler&quot;, errorHandlerException);</span>
<span class="fc" id="L552">                        break; // error handler itself failed — stop regardless of policy</span>
<span class="fc" id="L553">                    }</span>
                }
<span class="fc bfc" id="L555" title="All 2 branches covered.">                if (eventErrorPolicy == EventErrorPolicy.PROPAGATE_AND_LOG_ERRORS) {</span>
<span class="fc" id="L556">                    break;</span>
                }
<span class="fc" id="L558">            }</span>
<span class="fc" id="L559">        }</span>
<span class="fc" id="L560">    }</span>

    /**
     * Registers custom tool handlers for this session.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with tools.
     *
     * @param tools
     *            the list of tool definitions with handlers
     */
    void registerTools(List&lt;ToolDefinition&gt; tools) {
<span class="fc" id="L571">        toolHandlers.clear();</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (tools != null) {</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">            for (ToolDefinition tool : tools) {</span>
<span class="fc" id="L574">                toolHandlers.put(tool.name(), tool);</span>
<span class="fc" id="L575">            }</span>
        }
<span class="fc" id="L577">    }</span>

    /**
     * Retrieves a registered tool by name.
     *
     * @param name
     *            the tool name
     * @return the tool definition, or {@code null} if not found
     */
    ToolDefinition getTool(String name) {
<span class="fc" id="L587">        return toolHandlers.get(name);</span>
    }

    /**
     * Registers a handler for permission requests.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with permission
     * handling.
     *
     * @param handler
     *            the permission handler
     */
    void registerPermissionHandler(PermissionHandler handler) {
<span class="fc" id="L600">        permissionHandler.set(handler);</span>
<span class="fc" id="L601">    }</span>

    /**
     * Handles a permission request from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server requests permission for an operation.
     *
     * @param permissionRequestData
     *            the JSON data for the permission request
     * @return a future that resolves with the permission result
     */
    CompletableFuture&lt;PermissionRequestResult&gt; handlePermissionRequest(JsonNode permissionRequestData) {
<span class="fc" id="L613">        PermissionHandler handler = permissionHandler.get();</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">        if (handler == null) {</span>
<span class="fc" id="L615">            PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="fc" id="L616">            result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="fc" id="L617">            return CompletableFuture.completedFuture(result);</span>
        }

        try {
<span class="fc" id="L621">            PermissionRequest request = MAPPER.treeToValue(permissionRequestData, PermissionRequest.class);</span>
<span class="fc" id="L622">            var invocation = new PermissionInvocation();</span>
<span class="fc" id="L623">            invocation.setSessionId(sessionId);</span>
<span class="fc" id="L624">            return handler.handle(request, invocation).exceptionally(ex -&gt; {</span>
<span class="fc" id="L625">                LOG.log(Level.SEVERE, &quot;Permission handler threw an exception&quot;, ex);</span>
<span class="fc" id="L626">                PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="fc" id="L627">                result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="fc" id="L628">                return result;</span>
            });
<span class="fc" id="L630">        } catch (Exception e) {</span>
<span class="fc" id="L631">            LOG.log(Level.SEVERE, &quot;Failed to process permission request&quot;, e);</span>
<span class="fc" id="L632">            PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="fc" id="L633">            result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="fc" id="L634">            return CompletableFuture.completedFuture(result);</span>
        }
    }

    /**
     * Registers a handler for user input requests.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with user input
     * handling.
     *
     * @param handler
     *            the user input handler
     */
    void registerUserInputHandler(UserInputHandler handler) {
<span class="fc" id="L648">        userInputHandler.set(handler);</span>
<span class="fc" id="L649">    }</span>

    /**
     * Handles a user input request from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server requests user input.
     *
     * @param request
     *            the user input request
     * @return a future that resolves with the user input response
     */
    CompletableFuture&lt;UserInputResponse&gt; handleUserInputRequest(UserInputRequest request) {
<span class="fc" id="L661">        UserInputHandler handler = userInputHandler.get();</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (handler == null) {</span>
<span class="fc" id="L663">            return CompletableFuture.failedFuture(new IllegalStateException(&quot;No user input handler registered&quot;));</span>
        }

        try {
<span class="fc" id="L667">            var invocation = new UserInputInvocation().setSessionId(sessionId);</span>
<span class="fc" id="L668">            return handler.handle(request, invocation).exceptionally(ex -&gt; {</span>
<span class="fc" id="L669">                LOG.log(Level.SEVERE, &quot;User input handler threw an exception&quot;, ex);</span>
<span class="fc" id="L670">                throw new RuntimeException(&quot;User input handler error&quot;, ex);</span>
            });
<span class="fc" id="L672">        } catch (Exception e) {</span>
<span class="fc" id="L673">            LOG.log(Level.SEVERE, &quot;Failed to process user input request&quot;, e);</span>
<span class="fc" id="L674">            return CompletableFuture.failedFuture(e);</span>
        }
    }

    /**
     * Registers hook handlers for this session.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with hooks.
     *
     * @param hooks
     *            the hooks configuration
     */
    void registerHooks(SessionHooks hooks) {
<span class="fc" id="L687">        hooksHandler.set(hooks);</span>
<span class="fc" id="L688">    }</span>

    /**
     * Handles a hook invocation from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server invokes a hook.
     *
     * @param hookType
     *            the type of hook to invoke
     * @param input
     *            the hook input data
     * @return a future that resolves with the hook output
     */
    CompletableFuture&lt;Object&gt; handleHooksInvoke(String hookType, JsonNode input) {
<span class="fc" id="L702">        SessionHooks hooks = hooksHandler.get();</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if (hooks == null) {</span>
<span class="fc" id="L704">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L707">        var invocation = new HookInvocation().setSessionId(sessionId);</span>

        try {
<span class="fc bfc" id="L710" title="All 6 branches covered.">            switch (hookType) {</span>
                case &quot;preToolUse&quot; :
<span class="fc bfc" id="L712" title="All 2 branches covered.">                    if (hooks.getOnPreToolUse() != null) {</span>
<span class="fc" id="L713">                        PreToolUseHookInput preInput = MAPPER.treeToValue(input, PreToolUseHookInput.class);</span>
<span class="fc" id="L714">                        return hooks.getOnPreToolUse().handle(preInput, invocation)</span>
<span class="fc" id="L715">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;postToolUse&quot; :
<span class="fc bfc" id="L719" title="All 2 branches covered.">                    if (hooks.getOnPostToolUse() != null) {</span>
<span class="fc" id="L720">                        PostToolUseHookInput postInput = MAPPER.treeToValue(input, PostToolUseHookInput.class);</span>
<span class="fc" id="L721">                        return hooks.getOnPostToolUse().handle(postInput, invocation)</span>
<span class="fc" id="L722">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;userPromptSubmitted&quot; :
<span class="fc bfc" id="L726" title="All 2 branches covered.">                    if (hooks.getOnUserPromptSubmitted() != null) {</span>
<span class="fc" id="L727">                        UserPromptSubmittedHookInput promptInput = MAPPER.treeToValue(input,</span>
                                UserPromptSubmittedHookInput.class);
<span class="fc" id="L729">                        return hooks.getOnUserPromptSubmitted().handle(promptInput, invocation)</span>
<span class="fc" id="L730">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;sessionStart&quot; :
<span class="fc bfc" id="L734" title="All 2 branches covered.">                    if (hooks.getOnSessionStart() != null) {</span>
<span class="fc" id="L735">                        SessionStartHookInput startInput = MAPPER.treeToValue(input, SessionStartHookInput.class);</span>
<span class="fc" id="L736">                        return hooks.getOnSessionStart().handle(startInput, invocation)</span>
<span class="fc" id="L737">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;sessionEnd&quot; :
<span class="fc bfc" id="L741" title="All 2 branches covered.">                    if (hooks.getOnSessionEnd() != null) {</span>
<span class="fc" id="L742">                        SessionEndHookInput endInput = MAPPER.treeToValue(input, SessionEndHookInput.class);</span>
<span class="fc" id="L743">                        return hooks.getOnSessionEnd().handle(endInput, invocation)</span>
<span class="fc" id="L744">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                default :
<span class="fc" id="L748">                    LOG.fine(&quot;Unhandled hook type: &quot; + hookType);</span>
            }
<span class="fc" id="L750">        } catch (Exception e) {</span>
<span class="fc" id="L751">            LOG.log(Level.SEVERE, &quot;Failed to process hook invocation&quot;, e);</span>
<span class="fc" id="L752">            return CompletableFuture.failedFuture(e);</span>
<span class="fc" id="L753">        }</span>

<span class="fc" id="L755">        return CompletableFuture.completedFuture(null);</span>
    }

    /**
     * Gets the complete list of messages and events in the session.
     * &lt;p&gt;
     * This retrieves the full conversation history, including all user messages,
     * assistant responses, tool invocations, and other session events.
     *
     * @return a future that resolves with a list of all session events
     * @throws IllegalStateException
     *             if this session has been terminated
     * @see AbstractSessionEvent
     */
    public CompletableFuture&lt;List&lt;AbstractSessionEvent&gt;&gt; getMessages() {
<span class="fc" id="L770">        ensureNotTerminated();</span>
<span class="fc" id="L771">        return rpc.invoke(&quot;session.getMessages&quot;, Map.of(&quot;sessionId&quot;, sessionId), GetMessagesResponse.class)</span>
<span class="fc" id="L772">                .thenApply(response -&gt; {</span>
<span class="fc" id="L773">                    var events = new ArrayList&lt;AbstractSessionEvent&gt;();</span>
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">                    if (response.events() != null) {</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">                        for (JsonNode eventNode : response.events()) {</span>
                            try {
<span class="fc" id="L777">                                AbstractSessionEvent event = SessionEventParser.parse(eventNode);</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">                                if (event != null) {</span>
<span class="fc" id="L779">                                    events.add(event);</span>
                                }
<span class="nc" id="L781">                            } catch (Exception e) {</span>
<span class="nc" id="L782">                                LOG.log(Level.WARNING, &quot;Failed to parse event&quot;, e);</span>
<span class="fc" id="L783">                            }</span>
<span class="fc" id="L784">                        }</span>
                    }
<span class="fc" id="L786">                    return events;</span>
                });
    }

    /**
     * Aborts the currently processing message in this session.
     * &lt;p&gt;
     * Use this to cancel a long-running operation or stop the assistant from
     * continuing to generate a response.
     *
     * @return a future that completes when the abort is acknowledged
     * @throws IllegalStateException
     *             if this session has been terminated
     */
    public CompletableFuture&lt;Void&gt; abort() {
<span class="fc" id="L801">        ensureNotTerminated();</span>
<span class="fc" id="L802">        return rpc.invoke(&quot;session.abort&quot;, Map.of(&quot;sessionId&quot;, sessionId), Void.class);</span>
    }

    /**
     * Verifies that this session has not yet been terminated.
     *
     * @throws IllegalStateException
     *             if close() has already been invoked
     */
    private void ensureNotTerminated() {
<span class="fc bfc" id="L812" title="All 2 branches covered.">        if (isTerminated) {</span>
<span class="fc" id="L813">            throw new IllegalStateException(&quot;Session is closed&quot;);</span>
        }
<span class="fc" id="L815">    }</span>

    /**
     * Disposes the session and releases all associated resources.
     * &lt;p&gt;
     * This destroys the session on the server, clears all event handlers, and
     * releases tool and permission handlers. After calling this method, the session
     * cannot be used again. Subsequent calls to this method have no effect.
     */
    @Override
    public void close() {
<span class="fc" id="L826">        synchronized (this) {</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">            if (isTerminated) {</span>
<span class="fc" id="L828">                return; // Already terminated - no-op</span>
            }
<span class="fc" id="L830">            isTerminated = true;</span>
<span class="fc" id="L831">        }</span>

        try {
<span class="fc" id="L834">            rpc.invoke(&quot;session.destroy&quot;, Map.of(&quot;sessionId&quot;, sessionId), Void.class).get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L835">        } catch (Exception e) {</span>
<span class="nc" id="L836">            LOG.log(Level.FINE, &quot;Error destroying session&quot;, e);</span>
<span class="fc" id="L837">        }</span>

<span class="fc" id="L839">        eventHandlers.clear();</span>
<span class="fc" id="L840">        toolHandlers.clear();</span>
<span class="fc" id="L841">        permissionHandler.set(null);</span>
<span class="fc" id="L842">        userInputHandler.set(null);</span>
<span class="fc" id="L843">        hooksHandler.set(null);</span>
<span class="fc" id="L844">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
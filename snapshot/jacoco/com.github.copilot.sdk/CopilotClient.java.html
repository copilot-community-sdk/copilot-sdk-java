<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotClient.java</span></div><h1>CopilotClient.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.CreateSessionResponse;
import com.github.copilot.sdk.json.DeleteSessionResponse;
import com.github.copilot.sdk.json.GetAuthStatusResponse;
import com.github.copilot.sdk.json.GetLastSessionIdResponse;
import com.github.copilot.sdk.json.GetModelsResponse;
import com.github.copilot.sdk.json.GetStatusResponse;
import com.github.copilot.sdk.json.ListSessionsResponse;
import com.github.copilot.sdk.json.ModelInfo;
import com.github.copilot.sdk.json.PingResponse;
import com.github.copilot.sdk.json.ResumeSessionConfig;
import com.github.copilot.sdk.json.ResumeSessionResponse;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SessionLifecycleHandler;
import com.github.copilot.sdk.json.SessionListFilter;
import com.github.copilot.sdk.json.SessionMetadata;

/**
 * Provides a client for interacting with the Copilot CLI server.
 * &lt;p&gt;
 * The CopilotClient manages the connection to the Copilot CLI server and
 * provides methods to create and manage conversation sessions. It can either
 * spawn a CLI server process or connect to an existing server.
 * &lt;p&gt;
 * Example usage:
 *
 * &lt;pre&gt;{@code
 * try (var client = new CopilotClient()) {
 * 	client.start().get();
 *
 * 	var session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * 	session.on(AssistantMessageEvent.class, msg -&gt; {
 * 		System.out.println(msg.getData().content());
 * 	});
 *
 * 	session.send(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 */
public final class CopilotClient implements AutoCloseable {

<span class="fc" id="L64">    private static final Logger LOG = Logger.getLogger(CopilotClient.class.getName());</span>

    /**
     * Timeout, in seconds, used by {@link #close()} when waiting for graceful
     * shutdown via {@link #stop()}.
     */
    public static final int AUTOCLOSEABLE_TIMEOUT_SECONDS = 10;
    private final CopilotClientOptions options;
    private final CliServerManager serverManager;
<span class="fc" id="L73">    private final LifecycleEventManager lifecycleManager = new LifecycleEventManager();</span>
<span class="fc" id="L74">    private final Map&lt;String, CopilotSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span>
    private volatile CompletableFuture&lt;Connection&gt; connectionFuture;
<span class="fc" id="L76">    private volatile boolean disposed = false;</span>
    private final String optionsHost;
    private final Integer optionsPort;
    private volatile List&lt;ModelInfo&gt; modelsCache;
<span class="fc" id="L80">    private final Object modelsCacheLock = new Object();</span>

    /**
     * Creates a new CopilotClient with default options.
     */
    public CopilotClient() {
<span class="fc" id="L86">        this(new CopilotClientOptions());</span>
<span class="fc" id="L87">    }</span>

    /**
     * Creates a new CopilotClient with the specified options.
     *
     * @param options
     *            Options for creating the client
     * @throws IllegalArgumentException
     *             if mutually exclusive options are provided
     */
<span class="fc" id="L97">    public CopilotClient(CopilotClientOptions options) {</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        this.options = options != null ? options : new CopilotClientOptions();</span>

        // When cliUrl is set, auto-correct useStdio since we're connecting via TCP
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="fc" id="L102">            this.options.setUseStdio(false);</span>
        }

        // Validate mutually exclusive options: cliUrl and cliPath cannot both be set
<span class="pc bpc" id="L106" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">                &amp;&amp; this.options.getCliPath() != null) {</span>
<span class="fc" id="L108">            throw new IllegalArgumentException(&quot;CliUrl is mutually exclusive with CliPath&quot;);</span>
        }

        // Validate auth options with external server
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L113" title="All 4 branches covered.">                &amp;&amp; (this.options.getGitHubToken() != null || this.options.getUseLoggedInUser() != null)) {</span>
<span class="fc" id="L114">            throw new IllegalArgumentException(</span>
                    &quot;GitHubToken and UseLoggedInUser cannot be used with CliUrl (external server manages its own auth)&quot;);
        }

        // Parse CliUrl if provided
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="fc" id="L120">            URI uri = CliServerManager.parseCliUrl(this.options.getCliUrl());</span>
<span class="fc" id="L121">            this.optionsHost = uri.getHost();</span>
<span class="fc" id="L122">            this.optionsPort = uri.getPort();</span>
<span class="fc" id="L123">        } else {</span>
<span class="fc" id="L124">            this.optionsHost = null;</span>
<span class="fc" id="L125">            this.optionsPort = null;</span>
        }

<span class="fc" id="L128">        this.serverManager = new CliServerManager(this.options);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Starts the Copilot client and connects to the server.
     *
     * @return A future that completes when the connection is established
     */
    public CompletableFuture&lt;Void&gt; start() {
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (connectionFuture == null) {</span>
<span class="fc" id="L138">            synchronized (this) {</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                if (connectionFuture == null) {</span>
<span class="fc" id="L140">                    connectionFuture = startCore();</span>
                }
<span class="fc" id="L142">            }</span>
        }
<span class="fc" id="L144">        return connectionFuture.thenApply(c -&gt; null);</span>
    }

    private CompletableFuture&lt;Connection&gt; startCore() {
<span class="fc" id="L148">        LOG.fine(&quot;Starting Copilot client&quot;);</span>

<span class="fc" id="L150">        return CompletableFuture.supplyAsync(() -&gt; {</span>
            try {
                JsonRpcClient rpc;
<span class="fc" id="L153">                Process process = null;</span>

<span class="pc bpc" id="L155" title="3 of 4 branches missed.">                if (optionsHost != null &amp;&amp; optionsPort != null) {</span>
                    // External server (TCP)
<span class="nc" id="L157">                    rpc = serverManager.connectToServer(null, optionsHost, optionsPort);</span>
                } else {
                    // Child process (stdio or TCP)
<span class="fc" id="L160">                    CliServerManager.ProcessInfo processInfo = serverManager.startCliServer();</span>
<span class="fc" id="L161">                    process = processInfo.process();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">                    rpc = serverManager.connectToServer(process, processInfo.port() != null ? &quot;localhost&quot; : null,</span>
<span class="fc" id="L163">                            processInfo.port());</span>
                }

<span class="fc" id="L166">                Connection connection = new Connection(rpc, process);</span>

                // Register handlers for server-to-client calls
<span class="fc" id="L169">                RpcHandlerDispatcher dispatcher = new RpcHandlerDispatcher(sessions, lifecycleManager::dispatch);</span>
<span class="fc" id="L170">                dispatcher.registerHandlers(rpc);</span>

                // Verify protocol version
<span class="fc" id="L173">                verifyProtocolVersion(connection);</span>

<span class="fc" id="L175">                LOG.info(&quot;Copilot client connected&quot;);</span>
<span class="fc" id="L176">                return connection;</span>
<span class="fc" id="L177">            } catch (Exception e) {</span>
<span class="fc" id="L178">                String stderr = serverManager.getStderrOutput();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                if (!stderr.isEmpty()) {</span>
<span class="fc" id="L180">                    throw new CompletionException(</span>
                            new IOException(&quot;CLI process exited unexpectedly. stderr: &quot; + stderr, e));
                }
<span class="fc" id="L183">                throw new CompletionException(e);</span>
            }
        });
    }

    private void verifyProtocolVersion(Connection connection) throws Exception {
<span class="fc" id="L189">        int expectedVersion = SdkProtocolVersion.get();</span>
<span class="fc" id="L190">        var params = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L191">        params.put(&quot;message&quot;, null);</span>
<span class="fc" id="L192">        PingResponse pingResponse = connection.rpc.invoke(&quot;ping&quot;, params, PingResponse.class).get(30, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (pingResponse.protocolVersion() == null) {</span>
<span class="nc" id="L195">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
                    + &quot;, but server does not report a protocol version. &quot;
                    + &quot;Please update your server to ensure compatibility.&quot;);
        }

<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (pingResponse.protocolVersion() != expectedVersion) {</span>
<span class="nc" id="L201">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
<span class="nc" id="L202">                    + &quot;, but server reports version &quot; + pingResponse.protocolVersion() + &quot;. &quot;</span>
                    + &quot;Please update your SDK or server to ensure compatibility.&quot;);
        }
<span class="fc" id="L205">    }</span>

    /**
     * Stops the client and closes all sessions.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; stop() {
<span class="fc" id="L213">        var closeFutures = new ArrayList&lt;CompletableFuture&lt;Void&gt;&gt;();</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (CopilotSession session : new ArrayList&lt;&gt;(sessions.values())) {</span>
<span class="fc" id="L216">            closeFutures.add(CompletableFuture.runAsync(() -&gt; {</span>
                try {
<span class="fc" id="L218">                    session.close();</span>
<span class="nc" id="L219">                } catch (Exception e) {</span>
<span class="nc" id="L220">                    LOG.log(Level.WARNING, &quot;Error closing session &quot; + session.getSessionId(), e);</span>
<span class="fc" id="L221">                }</span>
<span class="fc" id="L222">            }));</span>
<span class="fc" id="L223">        }</span>
<span class="fc" id="L224">        sessions.clear();</span>

<span class="fc" id="L226">        return CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L227">                .thenCompose(v -&gt; cleanupConnection());</span>
    }

    /**
     * Forces an immediate stop of the client without graceful cleanup.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; forceStop() {
<span class="fc" id="L236">        disposed = true;</span>
<span class="fc" id="L237">        sessions.clear();</span>
<span class="fc" id="L238">        return cleanupConnection();</span>
    }

    private CompletableFuture&lt;Void&gt; cleanupConnection() {
<span class="fc" id="L242">        CompletableFuture&lt;Connection&gt; future = connectionFuture;</span>
<span class="fc" id="L243">        connectionFuture = null;</span>

        // Clear models cache
<span class="fc" id="L246">        modelsCache = null;</span>

<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (future == null) {</span>
<span class="fc" id="L249">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L252">        return future.thenAccept(connection -&gt; {</span>
            try {
<span class="fc" id="L254">                connection.rpc.close();</span>
<span class="nc" id="L255">            } catch (Exception e) {</span>
<span class="nc" id="L256">                LOG.log(Level.FINE, &quot;Error closing RPC&quot;, e);</span>
<span class="fc" id="L257">            }</span>

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            if (connection.process != null) {</span>
                try {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">                    if (connection.process.isAlive()) {</span>
<span class="fc" id="L262">                        connection.process.destroyForcibly();</span>
                    }
<span class="nc" id="L264">                } catch (Exception e) {</span>
<span class="nc" id="L265">                    LOG.log(Level.FINE, &quot;Error killing process&quot;, e);</span>
<span class="fc" id="L266">                }</span>
            }
<span class="fc" id="L268">        }).exceptionally(ex -&gt; null);</span>
    }

    /**
     * Creates a new Copilot session with the specified configuration.
     * &lt;p&gt;
     * The session maintains conversation state and can be used to send messages and
     * receive responses. Remember to close the session when done.
     *
     * @param config
     *            configuration for the session (model, tools, etc.)
     * @return a future that resolves with the created CopilotSession
     * @see #createSession()
     * @see SessionConfig
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession(SessionConfig config) {
<span class="fc" id="L284">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L285">            var request = SessionRequestBuilder.buildCreateRequest(config);</span>

<span class="fc" id="L287">            return connection.rpc.invoke(&quot;session.create&quot;, request, CreateSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L288">                var session = new CopilotSession(response.sessionId(), connection.rpc, response.workspacePath());</span>
<span class="fc" id="L289">                SessionRequestBuilder.configureSession(session, config);</span>
<span class="fc" id="L290">                sessions.put(response.sessionId(), session);</span>
<span class="fc" id="L291">                return session;</span>
            });
        });
    }

    /**
     * Creates a new Copilot session with default configuration.
     *
     * @return a future that resolves with the created CopilotSession
     * @see #createSession(SessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession() {
<span class="fc" id="L303">        return createSession(null);</span>
    }

    /**
     * Resumes an existing Copilot session.
     * &lt;p&gt;
     * This restores a previously saved session, allowing you to continue a
     * conversation. The session's history is preserved.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @param config
     *            configuration for the resumed session
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String)
     * @see #listSessions()
     * @see #getLastSessionId()
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId, ResumeSessionConfig config) {
<span class="fc" id="L322">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L323">            var request = SessionRequestBuilder.buildResumeRequest(sessionId, config);</span>

<span class="fc" id="L325">            return connection.rpc.invoke(&quot;session.resume&quot;, request, ResumeSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L326">                var session = new CopilotSession(response.sessionId(), connection.rpc, response.workspacePath());</span>
<span class="fc" id="L327">                SessionRequestBuilder.configureSession(session, config);</span>
<span class="fc" id="L328">                sessions.put(response.sessionId(), session);</span>
<span class="fc" id="L329">                return session;</span>
            });
        });
    }

    /**
     * Resumes an existing session with default configuration.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String, ResumeSessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId) {
<span class="fc" id="L343">        return resumeSession(sessionId, null);</span>
    }

    /**
     * Gets the current connection state.
     *
     * @return the current connection state
     * @see ConnectionState
     */
    public ConnectionState getState() {
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (connectionFuture == null)</span>
<span class="fc" id="L354">            return ConnectionState.DISCONNECTED;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (connectionFuture.isCompletedExceptionally())</span>
<span class="fc" id="L356">            return ConnectionState.ERROR;</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (!connectionFuture.isDone())</span>
<span class="fc" id="L358">            return ConnectionState.CONNECTING;</span>
<span class="fc" id="L359">        return ConnectionState.CONNECTED;</span>
    }

    /**
     * Pings the server to check connectivity.
     * &lt;p&gt;
     * This can be used to verify that the server is responsive and to check the
     * protocol version.
     *
     * @param message
     *            an optional message to echo back
     * @return a future that resolves with the ping response
     * @see PingResponse
     */
    public CompletableFuture&lt;PingResponse&gt; ping(String message) {
<span class="fc" id="L374">        return ensureConnected().thenCompose(connection -&gt; connection.rpc.invoke(&quot;ping&quot;,</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                Map.of(&quot;message&quot;, message != null ? message : &quot;&quot;), PingResponse.class));</span>
    }

    /**
     * Gets CLI status including version and protocol information.
     *
     * @return a future that resolves with the status response containing version
     *         and protocol version
     * @see GetStatusResponse
     */
    public CompletableFuture&lt;GetStatusResponse&gt; getStatus() {
<span class="fc" id="L386">        return ensureConnected()</span>
<span class="fc" id="L387">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;status.get&quot;, Map.of(), GetStatusResponse.class));</span>
    }

    /**
     * Gets current authentication status.
     *
     * @return a future that resolves with the authentication status
     * @see GetAuthStatusResponse
     */
    public CompletableFuture&lt;GetAuthStatusResponse&gt; getAuthStatus() {
<span class="fc" id="L397">        return ensureConnected().thenCompose(</span>
<span class="fc" id="L398">                connection -&gt; connection.rpc.invoke(&quot;auth.getStatus&quot;, Map.of(), GetAuthStatusResponse.class));</span>
    }

    /**
     * Lists available models with their metadata.
     * &lt;p&gt;
     * Results are cached after the first successful call to avoid rate limiting.
     * The cache is cleared when the client disconnects.
     *
     * @return a future that resolves with a list of available models
     * @see ModelInfo
     */
    public CompletableFuture&lt;List&lt;ModelInfo&gt;&gt; listModels() {
        // Check cache first
<span class="fc" id="L412">        List&lt;ModelInfo&gt; cached = modelsCache;</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L414">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(cached));</span>
        }

<span class="fc" id="L417">        return ensureConnected().thenCompose(connection -&gt; {</span>
            // Double-check cache inside lock
<span class="fc" id="L419">            synchronized (modelsCacheLock) {</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">                if (modelsCache != null) {</span>
<span class="nc" id="L421">                    return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(modelsCache));</span>
                }
<span class="fc" id="L423">            }</span>

<span class="fc" id="L425">            return connection.rpc.invoke(&quot;models.list&quot;, Map.of(), GetModelsResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L426">                List&lt;ModelInfo&gt; models = response.getModels();</span>
<span class="fc" id="L427">                synchronized (modelsCacheLock) {</span>
<span class="fc" id="L428">                    modelsCache = models;</span>
<span class="fc" id="L429">                }</span>
<span class="fc" id="L430">                return new ArrayList&lt;&gt;(models); // Return a copy to prevent cache mutation</span>
            });
        });
    }

    /**
     * Gets the ID of the most recently used session.
     * &lt;p&gt;
     * This is useful for resuming the last conversation without needing to list all
     * sessions.
     *
     * @return a future that resolves with the last session ID, or {@code null} if
     *         no sessions exist
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;String&gt; getLastSessionId() {
<span class="nc" id="L446">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L447">                connection -&gt; connection.rpc.invoke(&quot;session.getLastId&quot;, Map.of(), GetLastSessionIdResponse.class)</span>
<span class="nc" id="L448">                        .thenApply(GetLastSessionIdResponse::sessionId));</span>
    }

    /**
     * Deletes a session by ID.
     * &lt;p&gt;
     * This permanently removes the session and its conversation history.
     *
     * @param sessionId
     *            the ID of the session to delete
     * @return a future that completes when the session is deleted
     * @throws RuntimeException
     *             if the deletion fails
     */
    public CompletableFuture&lt;Void&gt; deleteSession(String sessionId) {
<span class="fc" id="L463">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="fc" id="L464">                .invoke(&quot;session.delete&quot;, Map.of(&quot;sessionId&quot;, sessionId), DeleteSessionResponse.class)</span>
<span class="fc" id="L465">                .thenAccept(response -&gt; {</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                    if (!response.success()) {</span>
<span class="nc" id="L467">                        throw new RuntimeException(&quot;Failed to delete session &quot; + sessionId + &quot;: &quot; + response.error());</span>
                    }
<span class="fc" id="L469">                    sessions.remove(sessionId);</span>
<span class="fc" id="L470">                }));</span>
    }

    /**
     * Lists all available sessions.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, and summaries.
     *
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions() {
<span class="fc" id="L484">        return listSessions(null);</span>
    }

    /**
     * Lists all available sessions with optional filtering.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, summaries, and context information. Use the filter parameter to
     * narrow down sessions by working directory, git repository, or branch.
     *
     * &lt;h2&gt;Example Usage&lt;/h2&gt;
     *
     * &lt;pre&gt;{@code
     * // List all sessions
     * var allSessions = client.listSessions().get();
     *
     * // Filter by repository
     * var filter = new SessionListFilter().setRepository(&quot;owner/repo&quot;);
     * var repoSessions = client.listSessions(filter).get();
     * }&lt;/pre&gt;
     *
     * @param filter
     *            optional filter to narrow down sessions by context fields, or
     *            {@code null} to list all sessions
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see SessionListFilter
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions(SessionListFilter filter) {
<span class="fc" id="L514">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            Map&lt;String, Object&gt; params = filter != null ? Map.of(&quot;filter&quot;, filter) : Map.of();</span>
<span class="fc" id="L516">            return connection.rpc.invoke(&quot;session.list&quot;, params, ListSessionsResponse.class)</span>
<span class="fc" id="L517">                    .thenApply(ListSessionsResponse::sessions);</span>
        });
    }

    /**
     * Gets the ID of the session currently displayed in the TUI.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @return a future that resolves with the session ID, or null if no foreground
     *         session is set
     */
    public CompletableFuture&lt;String&gt; getForegroundSessionId() {
<span class="nc" id="L531">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="nc" id="L532">                .invoke(&quot;session.getForeground&quot;, Map.of(),</span>
                        com.github.copilot.sdk.json.GetForegroundSessionResponse.class)
<span class="nc" id="L534">                .thenApply(com.github.copilot.sdk.json.GetForegroundSessionResponse::sessionId));</span>
    }

    /**
     * Requests the TUI to switch to displaying the specified session.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @param sessionId
     *            the ID of the session to display in the TUI
     * @return a future that completes when the operation is done
     * @throws RuntimeException
     *             if the operation fails
     */
    public CompletableFuture&lt;Void&gt; setForegroundSessionId(String sessionId) {
<span class="nc" id="L550">        return ensureConnected()</span>
<span class="nc" id="L551">                .thenCompose(</span>
<span class="nc" id="L552">                        connection -&gt; connection.rpc</span>
<span class="nc" id="L553">                                .invoke(&quot;session.setForeground&quot;, Map.of(&quot;sessionId&quot;, sessionId),</span>
                                        com.github.copilot.sdk.json.SetForegroundSessionResponse.class)
<span class="nc" id="L555">                                .thenAccept(response -&gt; {</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                                    if (!response.success()) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                                        throw new RuntimeException(response.error() != null</span>
<span class="nc" id="L558">                                                ? response.error()</span>
<span class="nc" id="L559">                                                : &quot;Failed to set foreground session&quot;);</span>
                                    }
<span class="nc" id="L561">                                }));</span>
    }

    /**
     * Subscribes to all session lifecycle events.
     * &lt;p&gt;
     * Lifecycle events are emitted when sessions are created, deleted, updated, or
     * change foreground/background state (in TUI+server mode).
     *
     * @param handler
     *            a callback that receives lifecycle events
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(SessionLifecycleHandler handler) {
<span class="fc" id="L575">        return lifecycleManager.subscribe(handler);</span>
    }

    /**
     * Subscribes to a specific session lifecycle event type.
     *
     * @param eventType
     *            the event type to listen for (use
     *            {@link com.github.copilot.sdk.json.SessionLifecycleEventTypes}
     *            constants)
     * @param handler
     *            a callback that receives events of the specified type
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(String eventType, SessionLifecycleHandler handler) {
<span class="fc" id="L590">        return lifecycleManager.subscribe(eventType, handler);</span>
    }

    private CompletableFuture&lt;Connection&gt; ensureConnected() {
<span class="fc bfc" id="L594" title="All 4 branches covered.">        if (connectionFuture == null &amp;&amp; !options.isAutoStart()) {</span>
<span class="fc" id="L595">            throw new IllegalStateException(&quot;Client not connected. Call start() first.&quot;);</span>
        }

<span class="fc" id="L598">        start();</span>
<span class="fc" id="L599">        return connectionFuture;</span>
    }

    /**
     * Closes this client using graceful shutdown semantics.
     * &lt;p&gt;
     * This method is intended for {@code try-with-resources} usage and blocks while
     * waiting for {@link #stop()} to complete, up to
     * {@link #AUTOCLOSEABLE_TIMEOUT_SECONDS} seconds. If shutdown fails or times
     * out, the error is logged at {@link Level#FINE} and the method returns.
     * &lt;p&gt;
     * This method is idempotent.
     *
     * @see #stop()
     * @see #forceStop()
     * @see #AUTOCLOSEABLE_TIMEOUT_SECONDS
     */
    @Override
    public void close() {
<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (disposed)</span>
<span class="fc" id="L619">            return;</span>
<span class="fc" id="L620">        disposed = true;</span>
        try {
<span class="fc" id="L622">            stop().get(AUTOCLOSEABLE_TIMEOUT_SECONDS, TimeUnit.SECONDS);</span>
<span class="nc" id="L623">        } catch (Exception e) {</span>
<span class="nc" id="L624">            LOG.log(Level.FINE, &quot;Error during close&quot;, e);</span>
<span class="fc" id="L625">        }</span>
<span class="fc" id="L626">    }</span>

<span class="fc" id="L628">    private static record Connection(JsonRpcClient rpc, Process process) {</span>
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>
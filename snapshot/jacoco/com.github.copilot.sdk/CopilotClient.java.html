<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotClient.java</span></div><h1>CopilotClient.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.SessionEventParser;
import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.CreateSessionRequest;
import com.github.copilot.sdk.json.CreateSessionResponse;
import com.github.copilot.sdk.json.DeleteSessionResponse;
import com.github.copilot.sdk.json.GetAuthStatusResponse;
import com.github.copilot.sdk.json.GetLastSessionIdResponse;
import com.github.copilot.sdk.json.GetModelsResponse;
import com.github.copilot.sdk.json.GetStatusResponse;
import com.github.copilot.sdk.json.ListSessionsResponse;
import com.github.copilot.sdk.json.ModelInfo;
import com.github.copilot.sdk.json.PermissionRequestResult;
import com.github.copilot.sdk.json.PingResponse;
import com.github.copilot.sdk.json.ResumeSessionConfig;
import com.github.copilot.sdk.json.ResumeSessionRequest;
import com.github.copilot.sdk.json.ResumeSessionResponse;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SessionMetadata;
import com.github.copilot.sdk.json.ToolDef;
import com.github.copilot.sdk.json.ToolDefinition;
import com.github.copilot.sdk.json.ToolInvocation;
import com.github.copilot.sdk.json.ToolResultObject;

/**
 * Provides a client for interacting with the Copilot CLI server.
 * &lt;p&gt;
 * The CopilotClient manages the connection to the Copilot CLI server and
 * provides methods to create and manage conversation sessions. It can either
 * spawn a CLI server process or connect to an existing server.
 * &lt;p&gt;
 * Example usage:
 *
 * &lt;pre&gt;{@code
 * try (CopilotClient client = new CopilotClient()) {
 * 	client.start().get();
 *
 * 	CopilotSession session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * 	session.on(evt -&gt; {
 * 		if (evt instanceof AssistantMessageEvent msg) {
 * 			System.out.println(msg.getData().getContent());
 * 		}
 * 	});
 *
 * 	session.send(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 */
public final class CopilotClient implements AutoCloseable {

<span class="fc" id="L84">    private static final Logger LOG = Logger.getLogger(CopilotClient.class.getName());</span>
<span class="fc" id="L85">    private static final ObjectMapper MAPPER = JsonRpcClient.getObjectMapper();</span>

    private final CopilotClientOptions options;
<span class="fc" id="L88">    private final Map&lt;String, CopilotSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span>
    private volatile CompletableFuture&lt;Connection&gt; connectionFuture;
<span class="fc" id="L90">    private volatile boolean disposed = false;</span>
    private final String optionsHost;
    private final Integer optionsPort;
    private volatile List&lt;ModelInfo&gt; modelsCache;
<span class="fc" id="L94">    private final Object modelsCacheLock = new Object();</span>
<span class="fc" id="L95">    private final List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; lifecycleHandlers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L96">    private final Map&lt;String, List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt;&gt; typedLifecycleHandlers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L97">    private final Object lifecycleHandlersLock = new Object();</span>

    /**
     * Creates a new CopilotClient with default options.
     */
    public CopilotClient() {
<span class="fc" id="L103">        this(new CopilotClientOptions());</span>
<span class="fc" id="L104">    }</span>

    /**
     * Creates a new CopilotClient with the specified options.
     *
     * @param options
     *            Options for creating the client
     * @throws IllegalArgumentException
     *             if mutually exclusive options are provided
     */
<span class="fc" id="L114">    public CopilotClient(CopilotClientOptions options) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        this.options = options != null ? options : new CopilotClientOptions();</span>

        // Validate mutually exclusive options
<span class="pc bpc" id="L118" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L119" title="All 4 branches covered.">                &amp;&amp; (this.options.isUseStdio() || this.options.getCliPath() != null)) {</span>
<span class="fc" id="L120">            throw new IllegalArgumentException(&quot;CliUrl is mutually exclusive with UseStdio and CliPath&quot;);</span>
        }

        // Validate auth options with external server
<span class="pc bpc" id="L124" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="pc bpc" id="L125" title="1 of 4 branches missed.">                &amp;&amp; (this.options.getGithubToken() != null || this.options.getUseLoggedInUser() != null)) {</span>
<span class="fc" id="L126">            throw new IllegalArgumentException(</span>
                    &quot;GithubToken and UseLoggedInUser cannot be used with CliUrl (external server manages its own auth)&quot;);
        }

        // Parse CliUrl if provided
<span class="pc bpc" id="L131" title="3 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="nc" id="L132">            URI uri = parseCliUrl(this.options.getCliUrl());</span>
<span class="nc" id="L133">            this.optionsHost = uri.getHost();</span>
<span class="nc" id="L134">            this.optionsPort = uri.getPort();</span>
<span class="nc" id="L135">        } else {</span>
<span class="fc" id="L136">            this.optionsHost = null;</span>
<span class="fc" id="L137">            this.optionsPort = null;</span>
        }
<span class="fc" id="L139">    }</span>

    private static URI parseCliUrl(String url) {
        // If it's just a port number, treat as localhost
        try {
<span class="nc" id="L144">            int port = Integer.parseInt(url);</span>
<span class="nc" id="L145">            return URI.create(&quot;http://localhost:&quot; + port);</span>
<span class="nc" id="L146">        } catch (NumberFormatException e) {</span>
            // Not a port number, continue
        }

        // Add scheme if missing
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if (!url.toLowerCase().startsWith(&quot;http://&quot;) &amp;&amp; !url.toLowerCase().startsWith(&quot;https://&quot;)) {</span>
<span class="nc" id="L152">            url = &quot;https://&quot; + url;</span>
        }

<span class="nc" id="L155">        return URI.create(url);</span>
    }

    /**
     * Starts the Copilot client and connects to the server.
     *
     * @return A future that completes when the connection is established
     */
    public CompletableFuture&lt;Void&gt; start() {
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (connectionFuture == null) {</span>
<span class="fc" id="L165">            synchronized (this) {</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">                if (connectionFuture == null) {</span>
<span class="fc" id="L167">                    connectionFuture = startCore();</span>
                }
<span class="fc" id="L169">            }</span>
        }
<span class="fc" id="L171">        return connectionFuture.thenApply(c -&gt; null);</span>
    }

    private CompletableFuture&lt;Connection&gt; startCore() {
<span class="fc" id="L175">        LOG.fine(&quot;Starting Copilot client&quot;);</span>

<span class="fc" id="L177">        return CompletableFuture.supplyAsync(() -&gt; {</span>
            try {
                Connection connection;

<span class="pc bpc" id="L181" title="3 of 4 branches missed.">                if (optionsHost != null &amp;&amp; optionsPort != null) {</span>
                    // External server (TCP)
<span class="nc" id="L183">                    connection = connectToServer(null, optionsHost, optionsPort);</span>
                } else {
                    // Child process (stdio or TCP)
<span class="fc" id="L186">                    ProcessInfo processInfo = startCliServer();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                    connection = connectToServer(processInfo.process, processInfo.port != null ? &quot;localhost&quot; : null,</span>
                            processInfo.port);
                }

                // Register handlers for server-to-client calls
<span class="fc" id="L192">                registerRpcHandlers(connection.rpc);</span>

                // Verify protocol version
<span class="fc" id="L195">                verifyProtocolVersion(connection);</span>

<span class="fc" id="L197">                LOG.info(&quot;Copilot client connected&quot;);</span>
<span class="fc" id="L198">                return connection;</span>
<span class="nc" id="L199">            } catch (Exception e) {</span>
<span class="nc" id="L200">                throw new CompletionException(e);</span>
            }
        });
    }

    private void registerRpcHandlers(JsonRpcClient rpc) {
        // Handle session events
<span class="fc" id="L207">        rpc.registerMethodHandler(&quot;session.event&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="fc" id="L209">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L210">                JsonNode eventNode = params.get(&quot;event&quot;);</span>
<span class="fc" id="L211">                LOG.fine(&quot;Received session.event: &quot; + eventNode);</span>

<span class="fc" id="L213">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L214" title="1 of 4 branches missed.">                if (session != null &amp;&amp; eventNode != null) {</span>
<span class="fc" id="L215">                    AbstractSessionEvent event = SessionEventParser.parse(eventNode.toString());</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                    if (event != null) {</span>
<span class="fc" id="L217">                        session.dispatchEvent(event);</span>
                    }
                }
<span class="nc" id="L220">            } catch (Exception e) {</span>
<span class="nc" id="L221">                LOG.log(Level.SEVERE, &quot;Error handling session event&quot;, e);</span>
<span class="fc" id="L222">            }</span>
<span class="fc" id="L223">        });</span>

        // Handle session lifecycle events
<span class="fc" id="L226">        rpc.registerMethodHandler(&quot;session.lifecycle&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                String type = params.has(&quot;type&quot;) ? params.get(&quot;type&quot;).asText() : &quot;&quot;;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                String sessionId = params.has(&quot;sessionId&quot;) ? params.get(&quot;sessionId&quot;).asText() : &quot;&quot;;</span>

<span class="fc" id="L231">                com.github.copilot.sdk.json.SessionLifecycleEvent event = new com.github.copilot.sdk.json.SessionLifecycleEvent();</span>
<span class="fc" id="L232">                event.setType(type);</span>
<span class="fc" id="L233">                event.setSessionId(sessionId);</span>

<span class="pc bpc" id="L235" title="1 of 4 branches missed.">                if (params.has(&quot;metadata&quot;) &amp;&amp; !params.get(&quot;metadata&quot;).isNull()) {</span>
<span class="fc" id="L236">                    com.github.copilot.sdk.json.SessionLifecycleEventMetadata metadata = MAPPER.treeToValue(</span>
<span class="fc" id="L237">                            params.get(&quot;metadata&quot;), com.github.copilot.sdk.json.SessionLifecycleEventMetadata.class);</span>
<span class="fc" id="L238">                    event.setMetadata(metadata);</span>
                }

<span class="fc" id="L241">                dispatchLifecycleEvent(event);</span>
<span class="nc" id="L242">            } catch (Exception e) {</span>
<span class="nc" id="L243">                LOG.log(Level.SEVERE, &quot;Error handling session lifecycle event&quot;, e);</span>
<span class="fc" id="L244">            }</span>
<span class="fc" id="L245">        });</span>

        // Handle tool calls
<span class="fc" id="L248">        rpc.registerMethodHandler(&quot;tool.call&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L249">            handleToolCall(rpc, requestId, params);</span>
<span class="fc" id="L250">        });</span>

        // Handle permission requests
<span class="fc" id="L253">        rpc.registerMethodHandler(&quot;permission.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L254">            handlePermissionRequest(rpc, requestId, params);</span>
<span class="fc" id="L255">        });</span>

        // Handle user input requests
<span class="fc" id="L258">        rpc.registerMethodHandler(&quot;userInput.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L259">            handleUserInputRequest(rpc, requestId, params);</span>
<span class="fc" id="L260">        });</span>

        // Handle hooks invocations
<span class="fc" id="L263">        rpc.registerMethodHandler(&quot;hooks.invoke&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L264">            handleHooksInvoke(rpc, requestId, params);</span>
<span class="fc" id="L265">        });</span>
<span class="fc" id="L266">    }</span>

    private void handleToolCall(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L269">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L271">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L272">                String toolCallId = params.get(&quot;toolCallId&quot;).asText();</span>
<span class="fc" id="L273">                String toolName = params.get(&quot;toolName&quot;).asText();</span>
<span class="fc" id="L274">                JsonNode arguments = params.get(&quot;arguments&quot;);</span>

<span class="fc" id="L276">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L278">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L279">                    return;</span>
                }

<span class="fc" id="L282">                ToolDefinition tool = session.getTool(toolName);</span>
<span class="pc bpc" id="L283" title="2 of 4 branches missed.">                if (tool == null || tool.getHandler() == null) {</span>
<span class="nc" id="L284">                    var result = new ToolResultObject().setTextResultForLlm(&quot;Tool '&quot; + toolName + &quot;' is not supported.&quot;)</span>
<span class="nc" id="L285">                            .setResultType(&quot;failure&quot;).setError(&quot;tool '&quot; + toolName + &quot;' not supported&quot;);</span>
<span class="nc" id="L286">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L287">                    return;</span>
                }

<span class="fc" id="L290">                var invocation = new ToolInvocation().setSessionId(sessionId).setToolCallId(toolCallId)</span>
<span class="fc" id="L291">                        .setToolName(toolName).setArguments(arguments);</span>

<span class="fc" id="L293">                tool.getHandler().invoke(invocation).thenAccept(result -&gt; {</span>
                    try {
                        ToolResultObject toolResult;
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                        if (result instanceof ToolResultObject tr) {</span>
<span class="nc" id="L297">                            toolResult = tr;</span>
                        } else {
<span class="fc" id="L299">                            toolResult = new ToolResultObject().setResultType(&quot;success&quot;).setTextResultForLlm(</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                                    result instanceof String s ? s : MAPPER.writeValueAsString(result));</span>
                        }
<span class="fc" id="L302">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, toolResult));</span>
<span class="nc" id="L303">                    } catch (Exception e) {</span>
<span class="nc" id="L304">                        LOG.log(Level.SEVERE, &quot;Error sending tool result&quot;, e);</span>
<span class="fc" id="L305">                    }</span>
<span class="fc" id="L306">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L308">                        var result = new ToolResultObject()</span>
<span class="fc" id="L309">                                .setTextResultForLlm(</span>
                                        &quot;Invoking this tool produced an error. Detailed information is not available.&quot;)
<span class="fc" id="L311">                                .setResultType(&quot;failure&quot;).setError(ex.getMessage());</span>
<span class="fc" id="L312">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L313">                    } catch (Exception e) {</span>
<span class="nc" id="L314">                        LOG.log(Level.SEVERE, &quot;Error sending tool error&quot;, e);</span>
<span class="fc" id="L315">                    }</span>
<span class="fc" id="L316">                    return null;</span>
                });
<span class="nc" id="L318">            } catch (Exception e) {</span>
<span class="nc" id="L319">                LOG.log(Level.SEVERE, &quot;Error handling tool call&quot;, e);</span>
                try {
<span class="nc" id="L321">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32603, e.getMessage());</span>
<span class="nc" id="L322">                } catch (IOException ioe) {</span>
<span class="nc" id="L323">                    LOG.log(Level.SEVERE, &quot;Failed to send error response&quot;, ioe);</span>
<span class="nc" id="L324">                }</span>
<span class="fc" id="L325">            }</span>
<span class="fc" id="L326">        });</span>
<span class="fc" id="L327">    }</span>

    private void handlePermissionRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L330">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L332">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L333">                JsonNode permissionRequest = params.get(&quot;permissionRequest&quot;);</span>

<span class="fc" id="L335">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L337">                    var result = new PermissionRequestResult()</span>
<span class="nc" id="L338">                            .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L339">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L340">                    return;</span>
                }

<span class="fc" id="L343">                session.handlePermissionRequest(permissionRequest).thenAccept(result -&gt; {</span>
                    try {
<span class="fc" id="L345">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L346">                    } catch (IOException e) {</span>
<span class="nc" id="L347">                        LOG.log(Level.SEVERE, &quot;Error sending permission result&quot;, e);</span>
<span class="fc" id="L348">                    }</span>
<span class="fc" id="L349">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="nc" id="L351">                        var result = new PermissionRequestResult()</span>
<span class="nc" id="L352">                                .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L353">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L354">                    } catch (IOException e) {</span>
<span class="nc" id="L355">                        LOG.log(Level.SEVERE, &quot;Error sending permission denied&quot;, e);</span>
<span class="nc" id="L356">                    }</span>
<span class="nc" id="L357">                    return null;</span>
                });
<span class="nc" id="L359">            } catch (Exception e) {</span>
<span class="nc" id="L360">                LOG.log(Level.SEVERE, &quot;Error handling permission request&quot;, e);</span>
<span class="fc" id="L361">            }</span>
<span class="fc" id="L362">        });</span>
<span class="fc" id="L363">    }</span>

    private void handleUserInputRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L366">        LOG.fine(&quot;Received userInput.request: &quot; + params);</span>
<span class="fc" id="L367">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L369">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L370">                String question = params.get(&quot;question&quot;).asText();</span>
<span class="fc" id="L371">                LOG.fine(&quot;Processing userInput for session &quot; + sessionId + &quot;, question: &quot; + question);</span>
<span class="fc" id="L372">                JsonNode choicesNode = params.get(&quot;choices&quot;);</span>
<span class="fc" id="L373">                JsonNode allowFreeformNode = params.get(&quot;allowFreeform&quot;);</span>

<span class="fc" id="L375">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">                LOG.fine(&quot;Found session: &quot; + (session != null));</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L378">                    LOG.fine(&quot;Session not found, sending error&quot;);</span>
<span class="nc" id="L379">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L380">                    return;</span>
                }

<span class="fc" id="L383">                var request = new com.github.copilot.sdk.json.UserInputRequest().setQuestion(question);</span>
<span class="pc bpc" id="L384" title="1 of 4 branches missed.">                if (choicesNode != null &amp;&amp; choicesNode.isArray()) {</span>
<span class="fc" id="L385">                    var choices = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">                    for (JsonNode choice : choicesNode) {</span>
<span class="fc" id="L387">                        choices.add(choice.asText());</span>
<span class="fc" id="L388">                    }</span>
<span class="fc" id="L389">                    request.setChoices(choices);</span>
                }
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                if (allowFreeformNode != null) {</span>
<span class="fc" id="L392">                    request.setAllowFreeform(allowFreeformNode.asBoolean());</span>
                }

<span class="fc" id="L395">                session.handleUserInputRequest(request).thenAccept(response -&gt; {</span>
                    try {
                        // Ensure answer is never null - CLI requires a non-null string
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                        String answer = response.getAnswer() != null ? response.getAnswer() : &quot;&quot;;</span>
<span class="fc" id="L399">                        LOG.fine(&quot;Sending userInput response: answer=&quot; + answer + &quot;, wasFreeform=&quot;</span>
<span class="fc" id="L400">                                + response.isWasFreeform());</span>
<span class="fc" id="L401">                        rpc.sendResponse(Long.parseLong(requestId),</span>
<span class="fc" id="L402">                                Map.of(&quot;answer&quot;, answer, &quot;wasFreeform&quot;, response.isWasFreeform()));</span>
<span class="nc" id="L403">                    } catch (IOException e) {</span>
<span class="nc" id="L404">                        LOG.log(Level.SEVERE, &quot;Error sending user input response&quot;, e);</span>
<span class="fc" id="L405">                    }</span>
<span class="fc" id="L406">                }).exceptionally(ex -&gt; {</span>
<span class="nc" id="L407">                    LOG.log(Level.WARNING, &quot;User input handler exception&quot;, ex);</span>
                    try {
<span class="nc" id="L409">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="nc" id="L410">                                &quot;User input handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L411">                    } catch (IOException e) {</span>
<span class="nc" id="L412">                        LOG.log(Level.SEVERE, &quot;Error sending user input error&quot;, e);</span>
<span class="nc" id="L413">                    }</span>
<span class="nc" id="L414">                    return null;</span>
                });
<span class="nc" id="L416">            } catch (Exception e) {</span>
<span class="nc" id="L417">                LOG.log(Level.SEVERE, &quot;Error handling user input request&quot;, e);</span>
<span class="fc" id="L418">            }</span>
<span class="fc" id="L419">        });</span>
<span class="fc" id="L420">    }</span>

    private void handleHooksInvoke(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L423">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L425">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L426">                String hookType = params.get(&quot;hookType&quot;).asText();</span>
<span class="fc" id="L427">                JsonNode input = params.get(&quot;input&quot;);</span>

<span class="fc" id="L429">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L431">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L432">                    return;</span>
                }

<span class="fc" id="L435">                session.handleHooksInvoke(hookType, input).thenAccept(output -&gt; {</span>
                    try {
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">                        if (output != null) {</span>
<span class="fc" id="L438">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, output));</span>
                        } else {
<span class="nc" id="L440">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, (Object) null));</span>
                        }
<span class="nc" id="L442">                    } catch (IOException e) {</span>
<span class="nc" id="L443">                        LOG.log(Level.SEVERE, &quot;Error sending hooks response&quot;, e);</span>
<span class="fc" id="L444">                    }</span>
<span class="fc" id="L445">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L447">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="fc" id="L448">                                &quot;Hooks handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L449">                    } catch (IOException e) {</span>
<span class="nc" id="L450">                        LOG.log(Level.SEVERE, &quot;Error sending hooks error&quot;, e);</span>
<span class="fc" id="L451">                    }</span>
<span class="fc" id="L452">                    return null;</span>
                });
<span class="nc" id="L454">            } catch (Exception e) {</span>
<span class="nc" id="L455">                LOG.log(Level.SEVERE, &quot;Error handling hooks invoke&quot;, e);</span>
<span class="fc" id="L456">            }</span>
<span class="fc" id="L457">        });</span>
<span class="fc" id="L458">    }</span>

    private void verifyProtocolVersion(Connection connection) throws Exception {
<span class="fc" id="L461">        int expectedVersion = SdkProtocolVersion.get();</span>
<span class="fc" id="L462">        var params = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L463">        params.put(&quot;message&quot;, null);</span>
<span class="fc" id="L464">        PingResponse pingResponse = connection.rpc.invoke(&quot;ping&quot;, params, PingResponse.class).get(30, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() == null) {</span>
<span class="nc" id="L467">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
                    + &quot;, but server does not report a protocol version. &quot;
                    + &quot;Please update your server to ensure compatibility.&quot;);
        }

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() != expectedVersion) {</span>
<span class="nc" id="L473">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
<span class="nc" id="L474">                    + &quot;, but server reports version &quot; + pingResponse.getProtocolVersion() + &quot;. &quot;</span>
                    + &quot;Please update your SDK or server to ensure compatibility.&quot;);
        }
<span class="fc" id="L477">    }</span>

    /**
     * Stops the client and closes all sessions.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; stop() {
<span class="fc" id="L485">        var closeFutures = new ArrayList&lt;CompletableFuture&lt;Void&gt;&gt;();</span>

<span class="pc bpc" id="L487" title="1 of 2 branches missed.">        for (CopilotSession session : new ArrayList&lt;&gt;(sessions.values())) {</span>
<span class="nc" id="L488">            closeFutures.add(CompletableFuture.runAsync(() -&gt; {</span>
                try {
<span class="nc" id="L490">                    session.close();</span>
<span class="nc" id="L491">                } catch (Exception e) {</span>
<span class="nc" id="L492">                    LOG.log(Level.WARNING, &quot;Error closing session &quot; + session.getSessionId(), e);</span>
<span class="nc" id="L493">                }</span>
<span class="nc" id="L494">            }));</span>
<span class="nc" id="L495">        }</span>
<span class="fc" id="L496">        sessions.clear();</span>

<span class="fc" id="L498">        return CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L499">                .thenCompose(v -&gt; cleanupConnection());</span>
    }

    /**
     * Forces an immediate stop of the client without graceful cleanup.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; forceStop() {
<span class="fc" id="L508">        sessions.clear();</span>
<span class="fc" id="L509">        return cleanupConnection();</span>
    }

    private CompletableFuture&lt;Void&gt; cleanupConnection() {
<span class="fc" id="L513">        CompletableFuture&lt;Connection&gt; future = connectionFuture;</span>
<span class="fc" id="L514">        connectionFuture = null;</span>

        // Clear models cache
<span class="fc" id="L517">        modelsCache = null;</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">        if (future == null) {</span>
<span class="fc" id="L520">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L523">        return future.thenAccept(connection -&gt; {</span>
            try {
<span class="fc" id="L525">                connection.rpc.close();</span>
<span class="nc" id="L526">            } catch (Exception e) {</span>
<span class="nc" id="L527">                LOG.log(Level.FINE, &quot;Error closing RPC&quot;, e);</span>
<span class="fc" id="L528">            }</span>

<span class="pc bpc" id="L530" title="1 of 2 branches missed.">            if (connection.process != null) {</span>
                try {
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                    if (connection.process.isAlive()) {</span>
<span class="fc" id="L533">                        connection.process.destroyForcibly();</span>
                    }
<span class="nc" id="L535">                } catch (Exception e) {</span>
<span class="nc" id="L536">                    LOG.log(Level.FINE, &quot;Error killing process&quot;, e);</span>
<span class="fc" id="L537">                }</span>
            }
<span class="pc" id="L539">        }).exceptionally(ex -&gt; null);</span>
    }

    /**
     * Creates a new Copilot session with the specified configuration.
     * &lt;p&gt;
     * The session maintains conversation state and can be used to send messages and
     * receive responses. Remember to close the session when done.
     *
     * @param config
     *            configuration for the session (model, tools, etc.)
     * @return a future that resolves with the created CopilotSession
     * @see #createSession()
     * @see SessionConfig
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession(SessionConfig config) {
<span class="fc" id="L555">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L556">            var request = new CreateSessionRequest();</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L558">                request.setModel(config.getModel());</span>
<span class="fc" id="L559">                request.setSessionId(config.getSessionId());</span>
<span class="fc" id="L560">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                request.setTools(config.getTools() != null</span>
<span class="fc" id="L562">                        ? config.getTools().stream()</span>
<span class="fc" id="L563">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="fc" id="L564">                                .collect(Collectors.toList())</span>
<span class="fc" id="L565">                        : null);</span>
<span class="fc" id="L566">                request.setSystemMessage(config.getSystemMessage());</span>
<span class="fc" id="L567">                request.setAvailableTools(config.getAvailableTools());</span>
<span class="fc" id="L568">                request.setExcludedTools(config.getExcludedTools());</span>
<span class="fc" id="L569">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                boolean requestUserInput = config.getOnUserInputRequest() != null;</span>
<span class="fc" id="L572">                LOG.fine(&quot;Setting requestUserInput: &quot; + requestUserInput + &quot; for session.create&quot;);</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">                request.setRequestUserInput(requestUserInput ? true : null);</span>
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L575">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L577">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L578">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L579">                request.setInfiniteSessions(config.getInfiniteSessions());</span>
<span class="fc" id="L580">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L581">                request.setDisabledSkills(config.getDisabledSkills());</span>
<span class="fc" id="L582">                request.setConfigDir(config.getConfigDir());</span>
            }

<span class="fc" id="L585">            return connection.rpc.invoke(&quot;session.create&quot;, request, CreateSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L586">                var session = new CopilotSession(response.getSessionId(), connection.rpc, response.getWorkspacePath());</span>
<span class="fc bfc" id="L587" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="fc" id="L588">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L590" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L591">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="fc bfc" id="L593" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="fc" id="L594">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="fc bfc" id="L596" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="fc" id="L597">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L599">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L600">                return session;</span>
            });
        });
    }

    /**
     * Creates a new Copilot session with default configuration.
     *
     * @return a future that resolves with the created CopilotSession
     * @see #createSession(SessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession() {
<span class="fc" id="L612">        return createSession(null);</span>
    }

    /**
     * Resumes an existing Copilot session.
     * &lt;p&gt;
     * This restores a previously saved session, allowing you to continue a
     * conversation. The session's history is preserved.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @param config
     *            configuration for the resumed session
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String)
     * @see #listSessions()
     * @see #getLastSessionId()
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId, ResumeSessionConfig config) {
<span class="fc" id="L631">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L632">            var request = new ResumeSessionRequest();</span>
<span class="fc" id="L633">            request.setSessionId(sessionId);</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L635">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">                request.setTools(config.getTools() != null</span>
<span class="nc" id="L637">                        ? config.getTools().stream()</span>
<span class="nc" id="L638">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="nc" id="L639">                                .collect(Collectors.toList())</span>
<span class="fc" id="L640">                        : null);</span>
<span class="fc" id="L641">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">                request.setRequestUserInput(config.getOnUserInputRequest() != null ? true : null);</span>
<span class="pc bpc" id="L644" title="3 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L645">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                request.setDisableResume(config.isDisableResume() ? true : null);</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L648">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L649">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L650">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L651">                request.setDisabledSkills(config.getDisabledSkills());</span>
            }

<span class="fc" id="L654">            return connection.rpc.invoke(&quot;session.resume&quot;, request, ResumeSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L655">                var session = new CopilotSession(response.getSessionId(), connection.rpc, response.getWorkspacePath());</span>
<span class="pc bpc" id="L656" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="nc" id="L657">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L659" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L660">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="pc bpc" id="L662" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="nc" id="L663">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="pc bpc" id="L665" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="nc" id="L666">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L668">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L669">                return session;</span>
            });
        });
    }

    /**
     * Resumes an existing session with default configuration.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String, ResumeSessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId) {
<span class="fc" id="L683">        return resumeSession(sessionId, null);</span>
    }

    /**
     * Gets the current connection state.
     *
     * @return the current connection state
     * @see ConnectionState
     */
    public ConnectionState getState() {
<span class="fc bfc" id="L693" title="All 2 branches covered.">        if (connectionFuture == null)</span>
<span class="fc" id="L694">            return ConnectionState.DISCONNECTED;</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        if (connectionFuture.isCompletedExceptionally())</span>
<span class="nc" id="L696">            return ConnectionState.ERROR;</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">        if (!connectionFuture.isDone())</span>
<span class="nc" id="L698">            return ConnectionState.CONNECTING;</span>
<span class="fc" id="L699">        return ConnectionState.CONNECTED;</span>
    }

    /**
     * Pings the server to check connectivity.
     * &lt;p&gt;
     * This can be used to verify that the server is responsive and to check the
     * protocol version.
     *
     * @param message
     *            an optional message to echo back
     * @return a future that resolves with the ping response
     * @see PingResponse
     */
    public CompletableFuture&lt;PingResponse&gt; ping(String message) {
<span class="fc" id="L714">        return ensureConnected().thenCompose(connection -&gt; connection.rpc.invoke(&quot;ping&quot;,</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">                Map.of(&quot;message&quot;, message != null ? message : &quot;&quot;), PingResponse.class));</span>
    }

    /**
     * Gets CLI status including version and protocol information.
     *
     * @return a future that resolves with the status response containing version
     *         and protocol version
     * @see GetStatusResponse
     */
    public CompletableFuture&lt;GetStatusResponse&gt; getStatus() {
<span class="fc" id="L726">        return ensureConnected()</span>
<span class="fc" id="L727">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;status.get&quot;, Map.of(), GetStatusResponse.class));</span>
    }

    /**
     * Gets current authentication status.
     *
     * @return a future that resolves with the authentication status
     * @see GetAuthStatusResponse
     */
    public CompletableFuture&lt;GetAuthStatusResponse&gt; getAuthStatus() {
<span class="fc" id="L737">        return ensureConnected().thenCompose(</span>
<span class="fc" id="L738">                connection -&gt; connection.rpc.invoke(&quot;auth.getStatus&quot;, Map.of(), GetAuthStatusResponse.class));</span>
    }

    /**
     * Lists available models with their metadata.
     * &lt;p&gt;
     * Results are cached after the first successful call to avoid rate limiting.
     * The cache is cleared when the client disconnects.
     *
     * @return a future that resolves with a list of available models
     * @see ModelInfo
     */
    public CompletableFuture&lt;List&lt;ModelInfo&gt;&gt; listModels() {
        // Check cache first
<span class="fc" id="L752">        List&lt;ModelInfo&gt; cached = modelsCache;</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L754">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(cached));</span>
        }

<span class="fc" id="L757">        return ensureConnected().thenCompose(connection -&gt; {</span>
            // Double-check cache inside lock
<span class="fc" id="L759">            synchronized (modelsCacheLock) {</span>
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">                if (modelsCache != null) {</span>
<span class="nc" id="L761">                    return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(modelsCache));</span>
                }
<span class="fc" id="L763">            }</span>

<span class="fc" id="L765">            return connection.rpc.invoke(&quot;models.list&quot;, Map.of(), GetModelsResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L766">                List&lt;ModelInfo&gt; models = response.getModels();</span>
<span class="fc" id="L767">                synchronized (modelsCacheLock) {</span>
<span class="fc" id="L768">                    modelsCache = models;</span>
<span class="fc" id="L769">                }</span>
<span class="fc" id="L770">                return new ArrayList&lt;&gt;(models); // Return a copy to prevent cache mutation</span>
            });
        });
    }

    /**
     * Gets the ID of the most recently used session.
     * &lt;p&gt;
     * This is useful for resuming the last conversation without needing to list all
     * sessions.
     *
     * @return a future that resolves with the last session ID, or {@code null} if
     *         no sessions exist
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;String&gt; getLastSessionId() {
<span class="nc" id="L786">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L787">                connection -&gt; connection.rpc.invoke(&quot;session.getLastId&quot;, Map.of(), GetLastSessionIdResponse.class)</span>
<span class="nc" id="L788">                        .thenApply(GetLastSessionIdResponse::getSessionId));</span>
    }

    /**
     * Deletes a session by ID.
     * &lt;p&gt;
     * This permanently removes the session and its conversation history.
     *
     * @param sessionId
     *            the ID of the session to delete
     * @return a future that completes when the session is deleted
     * @throws RuntimeException
     *             if the deletion fails
     */
    public CompletableFuture&lt;Void&gt; deleteSession(String sessionId) {
<span class="fc" id="L803">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="fc" id="L804">                .invoke(&quot;session.delete&quot;, Map.of(&quot;sessionId&quot;, sessionId), DeleteSessionResponse.class)</span>
<span class="fc" id="L805">                .thenAccept(response -&gt; {</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">                    if (!response.isSuccess()) {</span>
<span class="nc" id="L807">                        throw new RuntimeException(</span>
<span class="nc" id="L808">                                &quot;Failed to delete session &quot; + sessionId + &quot;: &quot; + response.getError());</span>
                    }
<span class="fc" id="L810">                    sessions.remove(sessionId);</span>
<span class="fc" id="L811">                }));</span>
    }

    /**
     * Lists all available sessions.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, and summaries.
     *
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions() {
<span class="fc" id="L825">        return ensureConnected()</span>
<span class="fc" id="L826">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;session.list&quot;, Map.of(), ListSessionsResponse.class)</span>
<span class="fc" id="L827">                        .thenApply(ListSessionsResponse::getSessions));</span>
    }

    /**
     * Gets the ID of the session currently displayed in the TUI.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @return a future that resolves with the session ID, or null if no foreground
     *         session is set
     */
    public CompletableFuture&lt;String&gt; getForegroundSessionId() {
<span class="nc" id="L840">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="nc" id="L841">                .invoke(&quot;session.getForeground&quot;, Map.of(),</span>
                        com.github.copilot.sdk.json.GetForegroundSessionResponse.class)
<span class="nc" id="L843">                .thenApply(com.github.copilot.sdk.json.GetForegroundSessionResponse::getSessionId));</span>
    }

    /**
     * Requests the TUI to switch to displaying the specified session.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @param sessionId
     *            the ID of the session to display in the TUI
     * @return a future that completes when the operation is done
     * @throws RuntimeException
     *             if the operation fails
     */
    public CompletableFuture&lt;Void&gt; setForegroundSessionId(String sessionId) {
<span class="nc" id="L859">        return ensureConnected()</span>
<span class="nc" id="L860">                .thenCompose(</span>
<span class="nc" id="L861">                        connection -&gt; connection.rpc</span>
<span class="nc" id="L862">                                .invoke(&quot;session.setForeground&quot;, Map.of(&quot;sessionId&quot;, sessionId),</span>
                                        com.github.copilot.sdk.json.SetForegroundSessionResponse.class)
<span class="nc" id="L864">                                .thenAccept(response -&gt; {</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">                                    if (!response.isSuccess()) {</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                                        throw new RuntimeException(response.getError() != null</span>
<span class="nc" id="L867">                                                ? response.getError()</span>
<span class="nc" id="L868">                                                : &quot;Failed to set foreground session&quot;);</span>
                                    }
<span class="nc" id="L870">                                }));</span>
    }

    /**
     * Subscribes to all session lifecycle events.
     * &lt;p&gt;
     * Lifecycle events are emitted when sessions are created, deleted, updated, or
     * change foreground/background state (in TUI+server mode).
     *
     * @param handler
     *            a callback that receives lifecycle events
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L884">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L885">            lifecycleHandlers.add(handler);</span>
<span class="nc" id="L886">        }</span>
<span class="nc" id="L887">        return () -&gt; {</span>
<span class="nc" id="L888">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L889">                lifecycleHandlers.remove(handler);</span>
<span class="nc" id="L890">            }</span>
<span class="nc" id="L891">        };</span>
    }

    /**
     * Subscribes to a specific session lifecycle event type.
     *
     * @param eventType
     *            the event type to listen for (use
     *            {@link com.github.copilot.sdk.json.SessionLifecycleEventTypes}
     *            constants)
     * @param handler
     *            a callback that receives events of the specified type
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(String eventType, com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L906">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L907">            typedLifecycleHandlers.computeIfAbsent(eventType, k -&gt; new ArrayList&lt;&gt;()).add(handler);</span>
<span class="nc" id="L908">        }</span>
<span class="nc" id="L909">        return () -&gt; {</span>
<span class="nc" id="L910">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L911">                List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="nc" id="L912">                        .get(eventType);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                if (handlers != null) {</span>
<span class="nc" id="L914">                    handlers.remove(handler);</span>
                }
<span class="nc" id="L916">            }</span>
<span class="nc" id="L917">        };</span>
    }

    void dispatchLifecycleEvent(com.github.copilot.sdk.json.SessionLifecycleEvent event) {
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; typed;
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; wildcard;

<span class="fc" id="L924">        synchronized (lifecycleHandlersLock) {</span>
<span class="fc" id="L925">            List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="fc" id="L926">                    .get(event.getType());</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">            typed = handlers != null ? new ArrayList&lt;&gt;(handlers) : new ArrayList&lt;&gt;();</span>
<span class="fc" id="L928">            wildcard = new ArrayList&lt;&gt;(lifecycleHandlers);</span>
<span class="fc" id="L929">        }</span>

<span class="pc bpc" id="L931" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : typed) {</span>
            try {
<span class="nc" id="L933">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L934">            } catch (Exception e) {</span>
<span class="nc" id="L935">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L936">            }</span>
<span class="nc" id="L937">        }</span>

<span class="pc bpc" id="L939" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : wildcard) {</span>
            try {
<span class="nc" id="L941">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L942">            } catch (Exception e) {</span>
<span class="nc" id="L943">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L944">            }</span>
<span class="nc" id="L945">        }</span>
<span class="fc" id="L946">    }</span>

    private CompletableFuture&lt;Connection&gt; ensureConnected() {
<span class="pc bpc" id="L949" title="1 of 4 branches missed.">        if (connectionFuture == null &amp;&amp; !options.isAutoStart()) {</span>
<span class="nc" id="L950">            throw new IllegalStateException(&quot;Client not connected. Call start() first.&quot;);</span>
        }

<span class="fc" id="L953">        start();</span>
<span class="fc" id="L954">        return connectionFuture;</span>
    }

    private ProcessInfo startCliServer() throws IOException, InterruptedException {
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">        String cliPath = options.getCliPath() != null ? options.getCliPath() : &quot;copilot&quot;;</span>
<span class="fc" id="L959">        var args = new ArrayList&lt;String&gt;();</span>

<span class="pc bpc" id="L961" title="1 of 2 branches missed.">        if (options.getCliArgs() != null) {</span>
<span class="nc" id="L962">            args.addAll(Arrays.asList(options.getCliArgs()));</span>
        }

<span class="fc" id="L965">        args.add(&quot;--server&quot;);</span>
<span class="fc" id="L966">        args.add(&quot;--log-level&quot;);</span>
<span class="fc" id="L967">        args.add(options.getLogLevel());</span>

<span class="fc bfc" id="L969" title="All 2 branches covered.">        if (options.isUseStdio()) {</span>
<span class="fc" id="L970">            args.add(&quot;--stdio&quot;);</span>
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">        } else if (options.getPort() &gt; 0) {</span>
<span class="nc" id="L972">            args.add(&quot;--port&quot;);</span>
<span class="nc" id="L973">            args.add(String.valueOf(options.getPort()));</span>
        }

        // Add auth-related flags
<span class="pc bpc" id="L977" title="1 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L978">            args.add(&quot;--auth-token-env&quot;);</span>
<span class="fc" id="L979">            args.add(&quot;COPILOT_SDK_AUTH_TOKEN&quot;);</span>
        }

        // Default UseLoggedInUser to false when GithubToken is provided
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        boolean useLoggedInUser = options.getUseLoggedInUser() != null</span>
<span class="nc" id="L984">                ? options.getUseLoggedInUser()</span>
<span class="pc bpc" id="L985" title="1 of 4 branches missed.">                : (options.getGithubToken() == null || options.getGithubToken().isEmpty());</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">        if (!useLoggedInUser) {</span>
<span class="fc" id="L987">            args.add(&quot;--no-auto-login&quot;);</span>
        }

<span class="fc" id="L990">        List&lt;String&gt; command = resolveCliCommand(cliPath, args);</span>

<span class="fc" id="L992">        var pb = new ProcessBuilder(command);</span>
<span class="fc" id="L993">        pb.redirectErrorStream(false);</span>

<span class="fc bfc" id="L995" title="All 2 branches covered.">        if (options.getCwd() != null) {</span>
<span class="fc" id="L996">            pb.directory(new File(options.getCwd()));</span>
        }

<span class="fc bfc" id="L999" title="All 2 branches covered.">        if (options.getEnvironment() != null) {</span>
<span class="fc" id="L1000">            pb.environment().clear();</span>
<span class="fc" id="L1001">            pb.environment().putAll(options.getEnvironment());</span>
        }
<span class="fc" id="L1003">        pb.environment().remove(&quot;NODE_DEBUG&quot;);</span>

        // Set auth token in environment if provided
<span class="pc bpc" id="L1006" title="1 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L1007">            pb.environment().put(&quot;COPILOT_SDK_AUTH_TOKEN&quot;, options.getGithubToken());</span>
        }

<span class="fc" id="L1010">        Process process = pb.start();</span>

        // Forward stderr to logger in background
<span class="fc" id="L1013">        var stderrThread = new Thread(() -&gt; {</span>
<span class="fc" id="L1014">            try (BufferedReader reader = new BufferedReader(</span>
<span class="fc" id="L1015">                    new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8))) {</span>
                String line;
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">                while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L1018">                    LOG.fine(&quot;[CLI] &quot; + line);</span>
                }
<span class="nc" id="L1020">            } catch (IOException e) {</span>
<span class="nc" id="L1021">                LOG.log(Level.FINE, &quot;Error reading stderr&quot;, e);</span>
<span class="fc" id="L1022">            }</span>
<span class="fc" id="L1023">        }, &quot;cli-stderr-reader&quot;);</span>
<span class="fc" id="L1024">        stderrThread.setDaemon(true);</span>
<span class="fc" id="L1025">        stderrThread.start();</span>

<span class="fc" id="L1027">        Integer detectedPort = null;</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">        if (!options.isUseStdio()) {</span>
            // Wait for port announcement
<span class="fc" id="L1030">            try (BufferedReader reader = new BufferedReader(</span>
<span class="fc" id="L1031">                    new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {</span>
<span class="fc" id="L1032">                Pattern portPattern = Pattern.compile(&quot;listening on port (\\d+)&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L1033">                long deadline = System.currentTimeMillis() + 30000;</span>

<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">                while (System.currentTimeMillis() &lt; deadline) {</span>
<span class="fc" id="L1036">                    String line = reader.readLine();</span>
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">                    if (line == null) {</span>
<span class="nc" id="L1038">                        throw new IOException(&quot;CLI process exited unexpectedly&quot;);</span>
                    }

<span class="fc" id="L1041">                    Matcher matcher = portPattern.matcher(line);</span>
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">                    if (matcher.find()) {</span>
<span class="fc" id="L1043">                        detectedPort = Integer.parseInt(matcher.group(1));</span>
<span class="fc" id="L1044">                        break;</span>
                    }
<span class="nc" id="L1046">                }</span>

<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">                if (detectedPort == null) {</span>
<span class="nc" id="L1049">                    process.destroyForcibly();</span>
<span class="nc" id="L1050">                    throw new IOException(&quot;Timeout waiting for CLI to announce port&quot;);</span>
                }
            }
        }

<span class="fc" id="L1055">        return new ProcessInfo(process, detectedPort);</span>
    }

    private List&lt;String&gt; resolveCliCommand(String cliPath, List&lt;String&gt; args) {
<span class="fc" id="L1059">        boolean isJsFile = cliPath.toLowerCase().endsWith(&quot;.js&quot;);</span>

<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        if (isJsFile) {</span>
<span class="fc" id="L1062">            var result = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L1063">            result.add(&quot;node&quot;);</span>
<span class="fc" id="L1064">            result.add(cliPath);</span>
<span class="fc" id="L1065">            result.addAll(args);</span>
<span class="fc" id="L1066">            return result;</span>
        }

        // On Windows, use cmd /c to resolve the executable
<span class="nc" id="L1070">        String os = System.getProperty(&quot;os.name&quot;).toLowerCase();</span>
<span class="nc bnc" id="L1071" title="All 4 branches missed.">        if (os.contains(&quot;win&quot;) &amp;&amp; !new File(cliPath).isAbsolute()) {</span>
<span class="nc" id="L1072">            var result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1073">            result.add(&quot;cmd&quot;);</span>
<span class="nc" id="L1074">            result.add(&quot;/c&quot;);</span>
<span class="nc" id="L1075">            result.add(cliPath);</span>
<span class="nc" id="L1076">            result.addAll(args);</span>
<span class="nc" id="L1077">            return result;</span>
        }

<span class="nc" id="L1080">        var result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1081">        result.add(cliPath);</span>
<span class="nc" id="L1082">        result.addAll(args);</span>
<span class="nc" id="L1083">        return result;</span>
    }

    private Connection connectToServer(Process process, String tcpHost, Integer tcpPort) throws IOException {
        JsonRpcClient rpc;

<span class="fc bfc" id="L1089" title="All 2 branches covered.">        if (options.isUseStdio()) {</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">            if (process == null) {</span>
<span class="nc" id="L1091">                throw new IllegalStateException(&quot;CLI process not started&quot;);</span>
            }
<span class="fc" id="L1093">            rpc = JsonRpcClient.fromProcess(process);</span>
        } else {
<span class="pc bpc" id="L1095" title="2 of 4 branches missed.">            if (tcpHost == null || tcpPort == null) {</span>
<span class="nc" id="L1096">                throw new IllegalStateException(&quot;Cannot connect because TCP host or port are not available&quot;);</span>
            }
<span class="fc" id="L1098">            Socket socket = new Socket(tcpHost, tcpPort);</span>
<span class="fc" id="L1099">            rpc = JsonRpcClient.fromSocket(socket);</span>
        }

<span class="fc" id="L1102">        return new Connection(rpc, process);</span>
    }

    @Override
    public void close() {
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">        if (disposed)</span>
<span class="nc" id="L1108">            return;</span>
<span class="fc" id="L1109">        disposed = true;</span>
        try {
<span class="fc" id="L1111">            forceStop().get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L1112">        } catch (Exception e) {</span>
<span class="nc" id="L1113">            LOG.log(Level.FINE, &quot;Error during close&quot;, e);</span>
<span class="fc" id="L1114">        }</span>
<span class="fc" id="L1115">    }</span>

<span class="fc" id="L1117">    private static record ProcessInfo(Process process, Integer port) {</span>
    };

<span class="fc" id="L1120">    private static record Connection(JsonRpcClient rpc, Process process) {</span>
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>